<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1.5 内存泄漏如何避免</title>
      <link href="/2017/05/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.5%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D/"/>
      <url>/2017/05/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.5%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>常用垃圾回收算法叫做<strong>标记清除 （Mark-and-sweep） </strong>，算法由以下几步组成：</p><ol><li><p>垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）</p></li><li><p>所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾</p></li><li><p>所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ol><p><strong>本质：</strong>可达内存被标记，其余的被当作垃圾回收</p><h4 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h4><h5 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h5><pre><code>1function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}</code></pre><p>函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。</p><pre><code>2function foo() {this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p><strong>解决方法：</strong>使用’use strict’</p><h5 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h5><pre><code>var someResource = getData();setInterval(function() {var node = document.getElementById(&apos;Node&apos;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&apos;button&apos;);function onClick(event) {    element.innerHTML = &apos;text&apos;;}element.addEventListener(&apos;click&apos;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。</p><p>现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。</p><h5 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h5><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&apos;button&apos;),    image: document.getElementById(&apos;image&apos;),    text: document.getElementById(&apos;text&apos;)};function doStuff() {    image.src = &apos;http://some.url/image&apos;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&apos;button&apos;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&apos;*&apos;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p><strong>解决方法：</strong>在 replaceThing 的最后添加 originalThing = null 。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>从内存来看 null 和 undefined 本质的区别是什么？</p><p>给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。<br>给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值</p></li><li><p>ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？</p><p> const foo = {};</p><p> // 为 foo 添加一个属性，可以成功<br> foo.prop = 123;<br> foo.prop // 123</p><p> // 将 foo 指向另一个对象，就会报错<br> foo = {}; // TypeError: “foo” is read-only</p></li></ol><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>]]></content>
      
      
      <categories>
          
          <category> js学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4 内存机制</title>
      <link href="/2017/05/22/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.4%20%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/05/22/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.4%20%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="JS内存空间"><a href="#JS内存空间" class="headerlink" title="JS内存空间"></a>JS内存空间</h4><p><strong>栈内存（stack）</strong>：存放变量</p><p><strong>堆内存（heap）</strong>：存放复杂对象</p><p><strong>池</strong>（一般也归类栈中）：存放常量</p><pre><code>function A() {  let a = 1  function B() {      console.log(a)  }  return B}</code></pre><h6 id="闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量"><a href="#闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量" class="headerlink" title="闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量"></a>闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量</h6><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>js有自动垃圾回收机制，垃圾收集器会每个一段时间就执行一次释放操作，找出那些不在继续使用的值，然后释放其占用的内存。</p><ol><li>局部变量和全局变量的销毁</li></ol><p><strong>局部变量：</strong>局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</p><p><strong>全局变量：</strong>全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量</p><ol start="2"><li>以Google的V8引擎为例，V8引擎中的所有的JS独享都是通过对来金鹰内粗分配的</li></ol><p><strong>初始分配</strong>：声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量</p><p><strong>继续申请</strong>：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止</p><ol start="3"><li>V8引擎对堆内存中的JS对象进行分代管理</li></ol><p><strong>新生代</strong>：存活周期较短的JS对象，如临时变量、字符串等。<br><strong>老生代</strong>：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不使用了，常用垃圾回收算法：</p><ul><li>引用计数（现在浏览器不再使用）</li><li>标记清除</li></ul><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &apos;aaaa&apos;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;   //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命问题就是<strong>循环引用</strong></p><pre><code>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。    function cycle() {        var o1 = {};        var o2 = {};        o1.a = o2;        o2.a = o1;         return &quot;cycle reference!&quot;    }    cycle();</code></pre><p>如果两个对象相互引用，尽管他们已经不在使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除将“将不再使用的队形”定义为无法到达的对象。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。</p><p>对于主流浏览器来说，只需要切断需要回收的对象与根部的联系，就可以被垃圾回收机制回收</p><pre><code>email.message = document.createElement(“div”);displayList.appendChild(email.message);// 稍后从displayList中清除DOM元素displayList.removeAllChildren();</code></pre><p>上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>对于持续与逆行的服务进程，必须及时释放不在用到的内存废旧则内存占用的越来越高，轻则影响到系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就叫做内存泄漏。</p><h4 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h4><ol><li>谷歌浏览器：Memory -&gt; Select profiling -&gt; timeline -&gt; start -&gt; stop</li><li>node process.memoryUsage</li></ol><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>ES6新的数据结构 WeakSet 和 WeakMap，表示这是弱引用，他们对于值的引用都是不计入垃圾回收机制的 </p><pre><code>const wm = new WeakMap();const element = document.getElementById(&apos;example&apos;);wm.set(element, &apos;some information&apos;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p>]]></content>
      
      
      <categories>
          
          <category> js学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3 栈堆队列理解</title>
      <link href="/2017/05/15/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.3%20%E6%A0%88%E5%A0%86%E9%98%9F%E5%88%97%E7%90%86%E8%A7%A3/"/>
      <url>/2017/05/15/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.3%20%E6%A0%88%E5%A0%86%E9%98%9F%E5%88%97%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h4><p>后进先出<strong>（LIFO）</strong></p><h4 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h4><p>堆是一种树状结构，存取类似于图书馆</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一种先进先出（FIFO）的数据结构</p><h4 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h4><ol><li>基本数据类型：保存在栈内存中，因为这些数据类型在内存中占有固定大小的空间，按值访问。</li></ol><p><strong>注：</strong> undefined null Boolean Number String Symbol</p><ol start="2"><li>引用数据类型：保存在堆内存中，因为这种值大小不固定，<br>但是内存地址（因为大小固定）保存在堆内存中；在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从<strong>栈中读取内存地址</strong>， 然后再通过地址<strong>找到堆中的值</strong>。对于这种，我们把它叫做按<strong>引用访问</strong>。</li></ol><h4 id="内存管理空间"><a href="#内存管理空间" class="headerlink" title="内存管理空间"></a>内存管理空间</h4><ol><li>分配你所需要的内存</li><li>使用分配到的内存</li><li>不需要时释放 归还</li></ol><p>JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。</p><p>在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。</p><pre><code>！！！赋值语句的执行顺序是从右至左var a = {n: 1};var b = a;a.x = a = {n: 2};a.x     // 这时 a.x 的值是多少b.x     // 这时 b.x 的值是多少</code></pre>]]></content>
      
      
      <categories>
          
          <category> js学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2 执行上下文栈和变量对象</title>
      <link href="/2017/05/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.2%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/05/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.2%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>变量提升：</strong></p><pre><code>foo;  // undefinedvar foo = function () {    console.log(&apos;foo1&apos;);}foo();  // foo1，foo赋值var foo = function () {    console.log(&apos;foo2&apos;);}foo(); // foo2，foo重新赋值</code></pre><p><strong>函数提升：</strong></p><pre><code>foo();  // foo2function foo() {    console.log(&apos;foo1&apos;);}foo();  // foo2function foo() {    console.log(&apos;foo2&apos;);}foo(); // foo2</code></pre><p><strong>变量提升和函数提升优先级：</strong></p><pre><code>foo();  // foo2var foo = function() {    console.log(&apos;foo1&apos;);}foo();  // foo1，foo重新赋值function foo() {    console.log(&apos;foo2&apos;);}foo(); // foo1</code></pre><p><strong>执行上下文栈</strong></p><pre><code>JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。</code></pre><p><strong>函数上下文</strong></p><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。<br>活动对象和变量对象的区别在于</p><p>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</p><p>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问</p><p><strong>执行过程</strong></p><ol><li><p>进入执行上下文</p><pre><code>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</code></pre></li></ol><pre><code>function foo(a) {  var b = 2;  function c() {}  var d = function() {};  b = 3;}foo(1);AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: undefined,    c: reference to function c(){},    d: undefined}</code></pre><ol start="2"><li>代码执行</li><li><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre></li></ol><p><strong>总结</strong></p><pre><code>1、全局上下文的变量对象初始化是全局对象2、函数上下文的变量对象初始化只包括 Arguments 对象3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值4、在代码执行阶段，会再次修改变量对象的属性值</code></pre>]]></content>
      
      
      <categories>
          
          <category> js学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1 执行上下文栈</title>
      <link href="/2017/04/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.1%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
      <url>/2017/04/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.1%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="执行上下文："><a href="#执行上下文：" class="headerlink" title="执行上下文："></a>执行上下文：</h4><p>当前javascript代码被解析和执行所在环境的抽象概念</p><h4 id="执行上下文类型："><a href="#执行上下文类型：" class="headerlink" title="执行上下文类型："></a>执行上下文类型：</h4><ol start="2"><li><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象</li><li><strong>函数执行上下文</strong>：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文</li><li><strong>Eval执行上下文</strong>: eval()函数中的代码,很少用而且不建议使用</li></ol><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈:"></a>执行栈:</h4><p>也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文</p><p>首次运行JS代码时，会创建一个<strong>全局执行上下文</strong>并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的<strong>函数执行上下文</strong>并Push到当前执行栈的栈顶。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>var a = &apos;1&apos;;function first() {    console.log(&apos;Inside first function&apos;);    second();    console.log(&apos;Again inside first function&apos;);  }function second() {    console.log(&apos;Inside second function&apos;);  }first();  console.log(&apos;Inside Global Execution Context&apos;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/11/5/166e258e1d0281a6?imageslim" alt=""></p><h4 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建:"></a>执行上下文的创建:</h4><p>执行上下文的创建分为两个阶段：</p><p><strong>1）创建阶段<br>2）执行阶段</strong></p><h5 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h5><ol><li><p>确定this</p><pre><code>全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象</code></pre></li><li><p>创建词法环境 （全局环境和函数环境）</p><pre><code>环境记录：存储变量和函数声明的实际位置对外部环境的访问：访问外部词法环境</code></pre></li><li><p>创建变量环境 </p><pre><code>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。</code></pre></li></ol><p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p><h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><pre><code>所有变量的分配，最后执行代码。</code></pre><p><strong>注：</strong> 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。</p>]]></content>
      
      
      <categories>
          
          <category> js学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 执行栈 </tag>
            
            <tag> 执行上下文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
