<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1.2 执行上下文栈和变量对象</title>
      <link href="/2017/05/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.2%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/05/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.2%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>变量提升：</strong></p><pre><code>foo;  // undefinedvar foo = function () {    console.log(&apos;foo1&apos;);}foo();  // foo1，foo赋值var foo = function () {    console.log(&apos;foo2&apos;);}foo(); // foo2，foo重新赋值</code></pre><p><strong>函数提升：</strong></p><pre><code>foo();  // foo2function foo() {    console.log(&apos;foo1&apos;);}foo();  // foo2function foo() {    console.log(&apos;foo2&apos;);}foo(); // foo2</code></pre><p><strong>变量提升和函数提升优先级：</strong></p><pre><code>foo();  // foo2var foo = function() {    console.log(&apos;foo1&apos;);}foo();  // foo1，foo重新赋值function foo() {    console.log(&apos;foo2&apos;);}foo(); // foo1</code></pre><p><strong>执行上下文栈</strong></p><pre><code>JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。</code></pre><p><strong>函数上下文</strong></p><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。<br>活动对象和变量对象的区别在于</p><p>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</p><p>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问</p><p><strong>执行过程</strong></p><ol><li><p>进入执行上下文</p><pre><code>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</code></pre></li></ol><pre><code>function foo(a) {  var b = 2;  function c() {}  var d = function() {};  b = 3;}foo(1);AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: undefined,    c: reference to function c(){},    d: undefined}</code></pre><ol start="2"><li>代码执行</li><li><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre></li></ol><p><strong>总结</strong></p><pre><code>1、全局上下文的变量对象初始化是全局对象2、函数上下文的变量对象初始化只包括 Arguments 对象3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值4、在代码执行阶段，会再次修改变量对象的属性值</code></pre>]]></content>
      
      
      <categories>
          
          <category> js学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1 执行上下文栈</title>
      <link href="/2017/04/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.1%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
      <url>/2017/04/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.1%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="执行上下文："><a href="#执行上下文：" class="headerlink" title="执行上下文："></a>执行上下文：</h4><p>当前javascript代码被解析和执行所在环境的抽象概念</p><h4 id="执行上下文类型："><a href="#执行上下文类型：" class="headerlink" title="执行上下文类型："></a>执行上下文类型：</h4><ol start="2"><li><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象</li><li><strong>函数执行上下文</strong>：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文</li><li><strong>Eval执行上下文</strong>: eval()函数中的代码,很少用而且不建议使用</li></ol><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈:"></a>执行栈:</h4><p>也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文</p><p>首次运行JS代码时，会创建一个<strong>全局执行上下文</strong>并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的<strong>函数执行上下文</strong>并Push到当前执行栈的栈顶。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>var a = &apos;1&apos;;function first() {    console.log(&apos;Inside first function&apos;);    second();    console.log(&apos;Again inside first function&apos;);  }function second() {    console.log(&apos;Inside second function&apos;);  }first();  console.log(&apos;Inside Global Execution Context&apos;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/11/5/166e258e1d0281a6?imageslim" alt=""></p><h4 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建:"></a>执行上下文的创建:</h4><p>执行上下文的创建分为两个阶段：</p><p><strong>1）创建阶段<br>2）执行阶段</strong></p><h5 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h5><ol><li><p>确定this</p><pre><code>全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象</code></pre></li><li><p>创建词法环境 （全局环境和函数环境）</p><pre><code>环境记录：存储变量和函数声明的实际位置对外部环境的访问：访问外部词法环境</code></pre></li><li><p>创建变量环境 </p><pre><code>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。</code></pre></li></ol><p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p><h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><pre><code>所有变量的分配，最后执行代码。</code></pre><p><strong>注：</strong> 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。</p>]]></content>
      
      
      <categories>
          
          <category> js学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 执行栈 </tag>
            
            <tag> 执行上下文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
