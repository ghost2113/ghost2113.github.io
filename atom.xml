<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>让优秀成为一种习惯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-17T12:55:37.518Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Tian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4.3 手动实现一个深拷贝</title>
    <link href="http://yoursite.com/2017/09/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.3%20%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2017/09/29/js学习笔记/4.3 手动实现一个深拷贝/</id>
    <published>2017-09-29T15:15:50.000Z</published>
    <updated>2019-05-17T12:55:37.518Z</updated>
    
    <summary type="html">
    
      this
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>4.2 Object.assign</title>
    <link href="http://yoursite.com/2017/09/12/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.2%20Object.assign/"/>
    <id>http://yoursite.com/2017/09/12/js学习笔记/4.2 Object.assign/</id>
    <published>2017-09-12T13:36:52.000Z</published>
    <updated>2019-05-17T12:55:31.434Z</updated>
    
    <summary type="html">
    
      Object.assign
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>4.1 解析赋值、浅拷贝、深拷贝</title>
    <link href="http://yoursite.com/2017/08/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.1%20%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/08/29/js学习笔记/4.1 解析赋值、浅拷贝、深拷贝的区别/</id>
    <published>2017-08-29T14:15:50.000Z</published>
    <updated>2019-05-17T12:55:25.907Z</updated>
    
    <summary type="html">
    
      解析赋值、浅拷贝、深拷贝
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>4.1 解析赋值、浅拷贝、深拷贝</title>
    <link href="http://yoursite.com/2017/08/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.1%20%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://yoursite.com/2017/08/29/js学习笔记/4.1 解析赋值、浅拷贝、深拷贝的区别 - 副本/</id>
    <published>2017-08-29T14:15:50.000Z</published>
    <updated>2019-05-17T12:56:02.074Z</updated>
    
    <summary type="html">
    
      解析赋值、浅拷贝、深拷贝
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>3.5 new</title>
    <link href="http://yoursite.com/2017/08/21/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.5%20new/"/>
    <id>http://yoursite.com/2017/08/21/js学习笔记/3.5 new/</id>
    <published>2017-08-21T12:15:50.000Z</published>
    <updated>2019-05-17T12:59:31.575Z</updated>
    
    <summary type="html">
    
      new
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>3.3 call和apply</title>
    <link href="http://yoursite.com/2017/08/21/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.3%20call%E5%92%8Capply/"/>
    <id>http://yoursite.com/2017/08/21/js学习笔记/3.3 call和apply/</id>
    <published>2017-08-20T23:15:50.000Z</published>
    <updated>2019-05-17T12:55:20.867Z</updated>
    
    <summary type="html">
    
      call apply
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>3.4 bind</title>
    <link href="http://yoursite.com/2017/08/20/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.4%20bind/"/>
    <id>http://yoursite.com/2017/08/20/js学习笔记/3.4 bind/</id>
    <published>2017-08-20T01:15:50.000Z</published>
    <updated>2019-05-17T12:59:24.257Z</updated>
    
    <summary type="html">
    
      bind
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>3.2 理解箭头函数中this</title>
    <link href="http://yoursite.com/2017/07/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.2%20%E7%90%86%E8%A7%A3%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis/"/>
    <id>http://yoursite.com/2017/07/29/js学习笔记/3.2 理解箭头函数中this/</id>
    <published>2017-07-29T12:15:50.000Z</published>
    <updated>2019-05-17T12:55:17.019Z</updated>
    
    <summary type="html">
    
      this
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>3.1 this的绑定方式</title>
    <link href="http://yoursite.com/2017/07/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.1%20this%E7%9A%84%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/07/19/js学习笔记/3.1 this的绑定方式/</id>
    <published>2017-07-19T01:15:50.000Z</published>
    <updated>2019-05-15T15:25:58.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="this的绑定："><a href="#this的绑定：" class="headerlink" title="this的绑定："></a>this的绑定：</h3><ul><li>默认绑定</li><li>隐式绑定</li><li>显式绑定</li><li>new绑定</li><li>箭头函数绑定</li></ul><h3 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h3><p>调用位置就是函数在代码中被调用的位置（而不是声明的位置）</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><ol><li><p><strong>独立函数的调用</strong>：this -&gt; window</p></li><li><p><strong>严格模式</strong>下，不能讲全局对象用于默认绑定，this会绑定到undefined.只有函数在非严格模式下，默认绑定才绑定到window上。</p></li></ol><pre><code>function foo() { // 运行在严格模式下，this会绑定到undefined&quot;use strict&quot;;console.log( this.a );}var a = 2;// 调用foo(); // TypeError: Cannot read property &apos;a&apos; of undefined// --------------------------------------function foo() { // 运行    console.log( this.a );}var a = 2;(function() { // 严格模式下调用函数则不影响默认绑定    &quot;use strict&quot;;    foo(); // 2})();</code></pre><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><pre><code>function foo() {console.log( this.a );}var obj = {a: 2,foo: foo};obj.foo(); // 2</code></pre><p>首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj 对象。</p><p>然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它</p><p>无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj ，因此 this.a 和 obj.a 是一样的。</p><p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置，举例来说：</p><pre><code>function foo() {console.log( this.a );}var obj2 = {a: 42,foo: foo};var obj1 = {a: 2,obj2: obj2};obj1.obj2.foo(); // 42</code></pre><h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式</p><pre><code>function foo() {    console.log( this.a );}var obj = {    a: 2,    foo: foo};var bar = obj.foo; // 函数别名！var a = &quot;oops, global&quot;; // a 是全局对象的属性bar(); // &quot;oops, global&quot;</code></pre><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时:</p><pre><code>function foo() {    console.log( this.a );}function doFoo(fn) {    // fn 其实引用的是 foo    fn(); // &lt;-- 调用位置！}var obj = {    a: 2,    foo: foo};var a = &quot;oops, global&quot;; // a 是全局对象的属性doFoo( obj.foo ); // &quot;oops, global&quot;</code></pre><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样</p><p>如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</p><pre><code>function foo() {    console.log( this.a );}var obj = {    a: 2,    foo: foo};var a = &quot;oops, global&quot;; // a 是全局对象的属性setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</code></pre><p>JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</p><pre><code>function setTimeout(fn,delay) {    // 等待 delay 毫秒    fn(); // &lt;-- 调用位置！}</code></pre><h4 id="显式绑定（call-apply）"><a href="#显式绑定（call-apply）" class="headerlink" title="显式绑定（call/apply）"></a>显式绑定（call/apply）</h4><p>在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。</p><p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？</p><p>JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关——之后我们会详细介绍原型），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。</p><p>call()和apply()的第一个参数是一个对象，他们会把这个对象绑定到this，在函数调用时指定这个this就是第一个参数对象，因为可以直接指定this的绑定对象，所以叫做显式绑定。</p><pre><code>function foo() {    console.log( this.a );}var obj = {    a:2};foo.call( obj ); // 2</code></pre><p>通过foo.call(obj), 我们在调用foo时会把他的this指定到obj对象。</p><p>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..) 、 new Boolean(..) 或者new Number(..) ）。这通常被称为<strong>“装箱”</strong></p><h5 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h5><p>解决我们之前提出的丢失绑定问题。</p><pre><code>function foo() {console.log( this.a );}var obj = {a:2};var bar = function() {foo.call( obj );};bar(); // 2setTimeout( bar, 100 ); // 2// 硬绑定的 bar 不可能再修改它的 thisbar.call( window ); // 2</code></pre><p>我们来看看这个变种到底是怎样工作的。我们创建了函数 bar() ，并在它的内部手动调用了 foo.call(obj) ，因此强制把 foo 的 this 绑定到了 obj 。无论之后如何调用函数 bar ，它总会手动在 obj 上调用 foo 。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p><strong>硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：</strong></p><pre><code>function foo(something) {    console.log( this.a, something );    return this.a + something;}var obj = {    a:2};var bar = function() {    return foo.apply( obj, arguments );};var b = bar( 3 ); // 2 3console.log( b ); // 5</code></pre><p><strong>另一种使用方法是创建一个 i 可以重复使用的辅助函数</strong></p><pre><code>function foo(something) {    console.log( this.a, something );    return this.a + something;}// 简单的辅助绑定函数function bind(fn, obj) {    return function() {    return fn.apply( obj, arguments );};}var obj = {    a:2};var bar = bind( foo, obj );var b = bar( 3 ); // 2 3console.log( b ); // 5</code></pre><p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p><h5 id="API调用的上下文"><a href="#API调用的上下文" class="headerlink" title="API调用的上下文"></a>API调用的上下文</h5><p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this 。</p><pre><code>function foo(el) {    console.log( el, this.id );}var obj = {    id: &quot;awesome&quot;};// 调用 foo(..) 时把 this 绑定到 obj[1, 2, 3].forEach( foo, obj );// 1 awesome 2 awesome 3 awesome</code></pre><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些代码。</p><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 JavaScript 中函数和对象的误解。</p><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的：</p><pre><code>something = new MyClass(..);</code></pre><p>JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它：<br>    当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。</p><p>所以，包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区<br>别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li><p>创建（或者说构造）一个全新的对象。</p></li><li><p>这个新对象会被执行 [[ 原型 ]] 连接。</p></li><li><p>这个新对象会绑定到函数调用的 this 。</p></li><li><p>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。<br>5<br>我们现在关心的是第 1 步、第 3 步、第 4 步，所以暂时跳过第 2 步，第 5 章会详细介绍它。</p></li></ol><p>思考下面的代码：<br>    function foo(a) {<br>    this.a = a;<br>    }<br>    var bar = new foo(2);<br>    console.log( bar.a ); // 2</p><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。 new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="链接：https://pan.baidu.com/s/1P6z3jjuYZnhoL-bA_2tq5Q">你不知道的javascript</a></p>]]></content>
    
    <summary type="html">
    
      this的绑定方式
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>2.2 从作用域链的角度看闭包</title>
    <link href="http://yoursite.com/2017/06/17/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.2%20%E4%BB%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/06/17/js学习笔记/2.2 从作用域的角度看闭包/</id>
    <published>2017-06-17T11:25:50.000Z</published>
    <updated>2019-05-15T15:10:37.473Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来看一个函数：</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}var foo = checkscope(); // foo指向函数ffoo();                    // 调用函数f()</code></pre><p><strong>执行过程</strong></p><ul><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li></ul><ul><li>全局执行上下文初始化</li></ul><ul><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li></ul><ul><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li></ul><ul><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li></ul><ul><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li></ul><ul><li>f 执行上下文初始化，创建变量对象、作用域链、this等</li></ul><ul><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ul><p>函数f执行的时候，checkscope函数执行上下文已经被销毁，那么f函数怎么访问到scope变量呢？</p><p>函数f 执行上下文维护了一个作用域链，会指向指向checkscope作用域</p><p>所以指向关系是当前作用域 –&gt; checkscope作用域–&gt; 全局作用域，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，这就是闭包实现的关键。</p>]]></content>
    
    <summary type="html">
    
      从作用域角度理解闭包
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>2.1 理解闭包</title>
    <link href="http://yoursite.com/2017/06/13/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.1%20%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>http://yoursite.com/2017/06/13/js学习笔记/2.1 闭包的作用和优缺点/</id>
    <published>2017-06-13T11:14:20.000Z</published>
    <updated>2019-05-14T14:07:16.123Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是闭包？闭包的优缺点？</strong></p><p>闭包（closure）是javascript的一大难点，也是它的特色。很多高级应用都要依靠闭包来实现。</p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>要理解闭包，首先要理解javascript的特殊的变量作用域。</p><p>变量的作用域无非就两种：全局变量和局部变量。</p><p><strong>javascript语言的特别之处就在于：</strong></p><p>函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。</p><p>注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！</p><h4 id="如何从外部读取函数内部的局部变量？"><a href="#如何从外部读取函数内部的局部变量？" class="headerlink" title="如何从外部读取函数内部的局部变量？"></a>如何从外部读取函数内部的局部变量？</h4><p>出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。</p><p>那就是在函数内部，再定义一个函数。</p><pre><code>function f1(){　　　　var n=999;　　　　function f2(){　　　　　　alert(n); // 999　　　　}　　}</code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。</p><p>这就是Javascript语言特有的”链式作用域”结构（chain scope），</p><p>子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><h4 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h4><p>上面代码中的f2函数，就是闭包。</p><p>各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。</p><p>由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。</p><p>所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><h4 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h4><p>闭包可以用在许多地方。它的最大用处有两个，</p><ol><li><p>一个是前面提到的可以读取函数内部的变量</p></li><li><p>另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除</p></li></ol><p><strong>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</strong></p><p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><h4 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h4><p>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>]]></content>
    
    <summary type="html">
    
      闭包
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>1.5 内存泄漏如何避免</title>
    <link href="http://yoursite.com/2017/05/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.5%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D/"/>
    <id>http://yoursite.com/2017/05/29/js学习笔记/1.5 内存泄漏如何避免/</id>
    <published>2017-05-29T13:34:20.000Z</published>
    <updated>2019-05-08T15:42:22.852Z</updated>
    
    <content type="html"><![CDATA[<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>常用垃圾回收算法叫做<strong>标记清除 （Mark-and-sweep） </strong>，算法由以下几步组成：</p><ol><li><p>垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）</p></li><li><p>所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾</p></li><li><p>所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ol><p><strong>本质：</strong>可达内存被标记，其余的被当作垃圾回收</p><h4 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h4><h5 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h5><pre><code>1function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}</code></pre><p>函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。</p><pre><code>2function foo() {this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p><strong>解决方法：</strong>使用’use strict’</p><h5 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h5><pre><code>var someResource = getData();setInterval(function() {var node = document.getElementById(&apos;Node&apos;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&apos;button&apos;);function onClick(event) {    element.innerHTML = &apos;text&apos;;}element.addEventListener(&apos;click&apos;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。</p><p>现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。</p><h5 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h5><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&apos;button&apos;),    image: document.getElementById(&apos;image&apos;),    text: document.getElementById(&apos;text&apos;)};function doStuff() {    image.src = &apos;http://some.url/image&apos;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&apos;button&apos;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&apos;*&apos;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p><strong>解决方法：</strong>在 replaceThing 的最后添加 originalThing = null 。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>从内存来看 null 和 undefined 本质的区别是什么？</p><p>给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。<br>给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值</p></li><li><p>ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？</p><p> const foo = {};</p><p> // 为 foo 添加一个属性，可以成功<br> foo.prop = 123;<br> foo.prop // 123</p><p> // 将 foo 指向另一个对象，就会报错<br> foo = {}; // TypeError: “foo” is read-only</p></li></ol><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>]]></content>
    
    <summary type="html">
    
      内存机制
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>1.4 内存机制</title>
    <link href="http://yoursite.com/2017/05/22/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.4%20%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/05/22/js学习笔记/1.4 内存机制/</id>
    <published>2017-05-22T11:11:20.000Z</published>
    <updated>2019-05-08T14:44:25.246Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS内存空间"><a href="#JS内存空间" class="headerlink" title="JS内存空间"></a>JS内存空间</h4><p><strong>栈内存（stack）</strong>：存放变量</p><p><strong>堆内存（heap）</strong>：存放复杂对象</p><p><strong>池</strong>（一般也归类栈中）：存放常量</p><pre><code>function A() {  let a = 1  function B() {      console.log(a)  }  return B}</code></pre><h6 id="闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量"><a href="#闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量" class="headerlink" title="闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量"></a>闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量</h6><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>js有自动垃圾回收机制，垃圾收集器会每个一段时间就执行一次释放操作，找出那些不在继续使用的值，然后释放其占用的内存。</p><ol><li>局部变量和全局变量的销毁</li></ol><p><strong>局部变量：</strong>局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</p><p><strong>全局变量：</strong>全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量</p><ol start="2"><li>以Google的V8引擎为例，V8引擎中的所有的JS独享都是通过对来金鹰内粗分配的</li></ol><p><strong>初始分配</strong>：声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量</p><p><strong>继续申请</strong>：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止</p><ol start="3"><li>V8引擎对堆内存中的JS对象进行分代管理</li></ol><p><strong>新生代</strong>：存活周期较短的JS对象，如临时变量、字符串等。<br><strong>老生代</strong>：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不使用了，常用垃圾回收算法：</p><ul><li>引用计数（现在浏览器不再使用）</li><li>标记清除</li></ul><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &apos;aaaa&apos;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;   //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命问题就是<strong>循环引用</strong></p><pre><code>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。    function cycle() {        var o1 = {};        var o2 = {};        o1.a = o2;        o2.a = o1;         return &quot;cycle reference!&quot;    }    cycle();</code></pre><p>如果两个对象相互引用，尽管他们已经不在使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除将“将不再使用的队形”定义为无法到达的对象。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。</p><p>对于主流浏览器来说，只需要切断需要回收的对象与根部的联系，就可以被垃圾回收机制回收</p><pre><code>email.message = document.createElement(“div”);displayList.appendChild(email.message);// 稍后从displayList中清除DOM元素displayList.removeAllChildren();</code></pre><p>上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>对于持续与逆行的服务进程，必须及时释放不在用到的内存废旧则内存占用的越来越高，轻则影响到系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就叫做内存泄漏。</p><h4 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h4><ol><li>谷歌浏览器：Memory -&gt; Select profiling -&gt; timeline -&gt; start -&gt; stop</li><li>node process.memoryUsage</li></ol><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>ES6新的数据结构 WeakSet 和 WeakMap，表示这是弱引用，他们对于值的引用都是不计入垃圾回收机制的 </p><pre><code>const wm = new WeakMap();const element = document.getElementById(&apos;example&apos;);wm.set(element, &apos;some information&apos;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p>]]></content>
    
    <summary type="html">
    
      内存机制
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>1.3 栈堆队列理解</title>
    <link href="http://yoursite.com/2017/05/15/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.3%20%E6%A0%88%E5%A0%86%E9%98%9F%E5%88%97%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/05/15/js学习笔记/1.3 栈堆队列理解/</id>
    <published>2017-05-15T01:11:48.000Z</published>
    <updated>2019-05-06T15:27:41.041Z</updated>
    
    <content type="html"><![CDATA[<h4 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h4><p>后进先出<strong>（LIFO）</strong></p><h4 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h4><p>堆是一种树状结构，存取类似于图书馆</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一种先进先出（FIFO）的数据结构</p><h4 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h4><ol><li>基本数据类型：保存在栈内存中，因为这些数据类型在内存中占有固定大小的空间，按值访问。</li></ol><p><strong>注：</strong> undefined null Boolean Number String Symbol</p><ol start="2"><li>引用数据类型：保存在堆内存中，因为这种值大小不固定，<br>但是内存地址（因为大小固定）保存在堆内存中；在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从<strong>栈中读取内存地址</strong>， 然后再通过地址<strong>找到堆中的值</strong>。对于这种，我们把它叫做按<strong>引用访问</strong>。</li></ol><h4 id="内存管理空间"><a href="#内存管理空间" class="headerlink" title="内存管理空间"></a>内存管理空间</h4><ol><li>分配你所需要的内存</li><li>使用分配到的内存</li><li>不需要时释放 归还</li></ol><p>JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。</p><p>在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。</p><pre><code>！！！赋值语句的执行顺序是从右至左var a = {n: 1};var b = a;a.x = a = {n: 2};a.x     // 这时 a.x 的值是多少b.x     // 这时 b.x 的值是多少</code></pre>]]></content>
    
    <summary type="html">
    
      堆、栈、队列
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>1.2 执行上下文栈和变量对象</title>
    <link href="http://yoursite.com/2017/05/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.2%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/05/06/js学习笔记/1.2 执行上下文栈和变量对象/</id>
    <published>2017-05-06T12:11:48.000Z</published>
    <updated>2019-05-06T14:59:10.977Z</updated>
    
    <content type="html"><![CDATA[<p><strong>变量提升：</strong></p><pre><code>foo;  // undefinedvar foo = function () {    console.log(&apos;foo1&apos;);}foo();  // foo1，foo赋值var foo = function () {    console.log(&apos;foo2&apos;);}foo(); // foo2，foo重新赋值</code></pre><p><strong>函数提升：</strong></p><pre><code>foo();  // foo2function foo() {    console.log(&apos;foo1&apos;);}foo();  // foo2function foo() {    console.log(&apos;foo2&apos;);}foo(); // foo2</code></pre><p><strong>变量提升和函数提升优先级：</strong></p><pre><code>foo();  // foo2var foo = function() {    console.log(&apos;foo1&apos;);}foo();  // foo1，foo重新赋值function foo() {    console.log(&apos;foo2&apos;);}foo(); // foo1</code></pre><p><strong>执行上下文栈</strong></p><pre><code>JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。</code></pre><p><strong>函数上下文</strong></p><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。<br>活动对象和变量对象的区别在于</p><p>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</p><p>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问</p><p><strong>执行过程</strong></p><ol><li><p>进入执行上下文</p><pre><code>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</code></pre></li></ol><pre><code>function foo(a) {  var b = 2;  function c() {}  var d = function() {};  b = 3;}foo(1);AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: undefined,    c: reference to function c(){},    d: undefined}</code></pre><ol start="2"><li>代码执行</li><li><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre></li></ol><p><strong>总结</strong></p><pre><code>1、全局上下文的变量对象初始化是全局对象2、函数上下文的变量对象初始化只包括 Arguments 对象3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值4、在代码执行阶段，会再次修改变量对象的属性值</code></pre>]]></content>
    
    <summary type="html">
    
      执行上下文栈、变量对象
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>1.1 执行上下文栈</title>
    <link href="http://yoursite.com/2017/04/29/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.1%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <id>http://yoursite.com/2017/04/29/js学习笔记/1.1 执行上下文栈/</id>
    <published>2017-04-29T12:31:48.000Z</published>
    <updated>2019-05-06T14:29:21.930Z</updated>
    
    <content type="html"><![CDATA[<h4 id="执行上下文："><a href="#执行上下文：" class="headerlink" title="执行上下文："></a>执行上下文：</h4><p>当前javascript代码被解析和执行所在环境的抽象概念</p><h4 id="执行上下文类型："><a href="#执行上下文类型：" class="headerlink" title="执行上下文类型："></a>执行上下文类型：</h4><ol start="2"><li><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象</li><li><strong>函数执行上下文</strong>：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文</li><li><strong>Eval执行上下文</strong>: eval()函数中的代码,很少用而且不建议使用</li></ol><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈:"></a>执行栈:</h4><p>也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文</p><p>首次运行JS代码时，会创建一个<strong>全局执行上下文</strong>并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的<strong>函数执行上下文</strong>并Push到当前执行栈的栈顶。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>var a = &apos;1&apos;;function first() {    console.log(&apos;Inside first function&apos;);    second();    console.log(&apos;Again inside first function&apos;);  }function second() {    console.log(&apos;Inside second function&apos;);  }first();  console.log(&apos;Inside Global Execution Context&apos;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/11/5/166e258e1d0281a6?imageslim" alt=""></p><h4 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建:"></a>执行上下文的创建:</h4><p>执行上下文的创建分为两个阶段：</p><p><strong>1）创建阶段<br>2）执行阶段</strong></p><h5 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h5><ol><li><p>确定this</p><pre><code>全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象</code></pre></li><li><p>创建词法环境 （全局环境和函数环境）</p><pre><code>环境记录：存储变量和函数声明的实际位置对外部环境的访问：访问外部词法环境</code></pre></li><li><p>创建变量环境 </p><pre><code>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。</code></pre></li></ol><p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p><h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><pre><code>所有变量的分配，最后执行代码。</code></pre><p><strong>注：</strong> 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。</p>]]></content>
    
    <summary type="html">
    
      执行上下文：当前javascript代码被解析和执行所在环境的抽象概念
    
    </summary>
    
      <category term="js学习笔记" scheme="http://yoursite.com/categories/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="执行栈" scheme="http://yoursite.com/tags/%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    
      <category term="执行上下文" scheme="http://yoursite.com/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
</feed>
