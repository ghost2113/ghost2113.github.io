{"meta":{"title":"让优秀成为一种习惯","subtitle":null,"description":"无数青山隔沧海,与谁同往却同归","author":"Mr.Tian","url":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g","root":"/"},"pages":[{"title":"about","date":"2020-03-25T13:05:34.000Z","updated":"2020-03-25T13:11:48.321Z","comments":true,"path":"about/index.html","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/about/index.html","excerpt":"","text":""},{"title":"archive","date":"2020-03-25T13:18:14.000Z","updated":"2020-03-25T13:18:40.164Z","comments":true,"path":"archives/index.html","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-16T12:31:48.000Z","updated":"2020-03-25T12:49:43.995Z","comments":true,"path":"categories/index.html","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-16T13:16:12.000Z","updated":"2019-04-16T13:21:33.365Z","comments":true,"path":"tags/index.html","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"github提供的webhook自动部署linux服务器","slug":"20200405","date":"2020-04-05T13:37:13.000Z","updated":"2020-04-05T13:40:24.425Z","comments":true,"path":"2020/04/05/20200405/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2020/04/05/20200405/","excerpt":"","text":"","categories":[],"tags":[{"name":"github webhook 自动部署","slug":"github-webhook-自动部署","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/github-webhook-自动部署/"}]},{"title":"把你的网页变黑白——css3神奇的filter滤镜","slug":"css滤镜style-filter","date":"2020-04-04T02:31:38.000Z","updated":"2020-04-10T13:56:04.379Z","comments":true,"path":"2020/04/04/css滤镜style-filter/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2020/04/04/css滤镜style-filter/","excerpt":"","text":"css中的强大滤镜css语法CCS滤镜参考语法12STYLE=&quot;filter:filtername(fparameter1, fparameter2...)&quot; （Filtername为滤镜的名称，fparameter1、fparameter2等是滤镜的HTMLElement.filters.filterName.fParameter=value; script 语法：1HTMLElement.filters.filterName.fParameter=value; filter 描述 blur(px) 模糊 opacity(%) 透明度 brightness(%) 亮度 drop-shadow(h-shadow v-shadow blur spread color) 阴影 grayscale(%) 单元格 hue-rotate(deg) 色相旋转 invert(%) 反色 opacity(%) 单元格 saturate(%) 饱和度 sepia(%) 褐色 contrast(%) 对比度 url() URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素,eg:filter: url(svg-url#element-id) 看下虎扑灰度图像的CSS123456789101112var beginDate = new Date(2020, 3, 4, 0);var endDate = new Date(2020, 3, 5, 9);var today = new Date();if (today &gt;= beginDate &amp;&amp; today &lt;= endDate) &#123; var root = document.documentElement; root.style.filter = &apos;grayscale(100%)&apos;; root.style.webkitFilter = &apos;grayscale(100%)&apos;; root.style.MozFilter = &apos;grayscale(100%)&apos;; root.style.OFilter = &apos;grayscale(100%)&apos;; root.style.msFilter = &apos;grayscale(100%)&apos;;&#125;","categories":[{"name":"css","slug":"css","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/css/"}],"tags":[{"name":"css filter grayscale","slug":"css-filter-grayscale","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/css-filter-grayscale/"}]},{"title":"apidoc使用指南","slug":"apidoc","date":"2020-04-01T14:39:41.000Z","updated":"2020-04-01T14:42:51.743Z","comments":true,"path":"2020/04/01/apidoc/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2020/04/01/apidoc/","excerpt":"","text":"apiDOC使用指南官网 安装123npm install apidoc -goryarn add apidoc global 配置文件在项目目录创建apidoc.json配置文件1234567&#123; &quot;name&quot;: &quot;ServiceEbikeAPIs&quot;, &quot;version&quot;: &quot;3.1.0&quot;, &quot;description&quot;: &quot;车辆服务接口文档&quot;, &quot;title&quot;: &quot;ServiceEbikeAPIs&quot;, &quot;url&quot; : &quot;http://cjl3.rokyinfo.net:7190/api-ebike&quot;&#125; 使用案例12345678910111213141516171819202122232425262728293031323334353637383940414243/*** @apiDefine SuccessResponse* @apiSuccessExample Response (success):* &#123;* &quot;code&quot;:&quot;0&quot;* &quot;error_message&quot;: &quot;&quot;* &quot;data&quot;:&quot;内容&quot;* &#125;*//** * @api &#123;get&#125; apiDeprecated/info * @apiName apiDeprecated * @apiGroup api2 * @apiHeader &#123;String&#125; token Users unique access-key. * @apiPermission none * @apiDeprecated 废弃，使用 (#getVersion:info) * Example: to set a link to the GetDetails method of your group User * write (#User:GetDetails) * @apiParamExample &#123;json&#125; Request-Example: * &#123; * &quot;id&quot;: 4711 * &#125; * @apiParam &#123;string&#125; [firstname] Optional Firstname of the User. * @apiParam &#123;String&#125; lastname Mandatory Lastname. * @apiParam &#123;String&#125; country=&quot;DE&quot; Mandatory with default value &quot;DE&quot;. * @apiParam &#123;Number&#125; [age=18] Optional Age with default 18. * @apiParam &#123;Object&#125; user * @apiParam &#123;Number&#125; user.age this is the age of user * @apiParam &#123;String&#125; user.name this is the name of user * @apiParam (Login) &#123;String&#125; pass Only logged in users can post this. * In generated documentation a separate * &quot;Login&quot; Block will be generated. * @apiuse SuccessResponse * @apiErrorExample &#123;string&#125; Error-reponse * HTTP/1.1 404 NOT found * &#123; * &quot;error&quot;: &quot;404&quot; * &#125; */function request() &#123;return&#125;/** * @apiError UserNotFound The &lt;code&gt;id&lt;/code&gt; of the User was not found. */ apiDoc参数@api1@api &#123;method&#125; path [title] 123/** * @api &#123;get&#125; getVersion/info 获取版本号 */ @apiVersion1@apiVersion version 1234/** * @api &#123;get&#125; getVersion/info * @apiVersion 1.0.0 */ @apiName1@apiName name 12345/** * @api &#123;get&#125; getVersion/info * @apiVersion 1.0.0 * @apiName 获取版本号 */ @apiDefine/@apiUse1@apiDefine name [title] [description] 1234567891011/** * @apiDefine MyError * @apiError UserNotFound The &lt;code&gt;id&lt;/code&gt; of the User was not found. *//** * @api &#123;get&#125; getVersion/info * @apiVersion 1.0.0 * @apiName 获取版本号 * @apiUse MyError */ @apiDescription1@apiDescription test 1234567/** * @api &#123;get&#125; getVersion/info * @apiDescription This is the Description. * It is multiline capable. * * Last line of Description. */ @apiError1@apiError [(group)] [&#123;type&#125;] field [description] 123456/** * @api &#123;get&#125; /user/:id * @apiError UserNotFound The &lt;code&gt;id&lt;/code&gt; of the User was not found. * @apiError &#123;number&#123;1000,1001&#125;&#125; errorcode 错误码 * @apiError &#123;Boolean&#123;true,false&#125;&#125; isInited 是否初始化 */ @apiErrorExample1@apiErrorExample [&#123;type&#125;] [title] [description] 12345678910111213/** * @api &#123;get&#125; /user/:id * @apiErrorExample &#123;json&#125; Error-Response: * HTTP/1.1 404 Not Found * &#123; * &quot;error&quot;: &quot;UserNotFound&quot; * &#125; * @apiErrorExample &#123;json&#125; Error-Response: * HTTP/1.1 404 Not Found * &#123; * &quot;error&quot;: &quot;UserNotFound&quot; * &#125; */ @apiExample1@apiExample[&#123;type&#125;] [title] example 12345678910/** * @api &#123;get&#125; /user/:id * @apiExample &#123;js&#125; Example usage: * axios(&apos;http://10.35.33.246:9001/getVersion/info&apos;).then((res)=&gt;&#123; * ... * &#125;) * .catch(error=&gt;&#123; * ... * &#125;) */ @apiExample1@apiGroup name 1234/** * @api &#123;get&#125; /user/:id * @apiGroup /user */ @apiHeader 请求头参数1@apiHeader [(group)] [&#123;type&#125;] [field=defaultValue] [descr] 1234/** * @api &#123;get&#125; /user/:id * @apiHeader &#123;string&#125; access-key Users unique access-key */ @apiHeaderExample 声明两次自动tab标签项1@apiHeader [(group)] [&#123;type&#125;] [field=defaultValue] [descr] 12345678/** * @api &#123;get&#125; /user/:id * @apiHeader &#123;string&#125; access-key Users unique access-key * @apiHeaderExample &#123;json&#125; Header-Example: * &#123; * &quot;Accept-Encoding&quot;: &quot;Accept-Encoding: gzip, deflate&quot; * &#125; */ @apiParam/apiParamExample 声明两次自动tab标签项1@apiParam [(group)] [&#123;type&#125;] [field=defaultValue] [description] 123456789101112131415161718192021/** * @api &#123;get&#125; /user/:id * @apiParam &#123;string&#125; [firstname] Optional Firstname of the User. * @apiParam &#123;String&#125; lastname Mandatory Lastname. * @apiParam &#123;String&#125; country=&quot;DE&quot; Mandatory with default value &quot;DE&quot;. * @apiParam &#123;Number&#125; [age=18] Optional Age with default 18. * @apiParam &#123;Object&#125; user * @apiParam &#123;Number&#125; user.age this is the age of user * @apiParam &#123;String&#125; user.name this is the name of user * @apiParam (Login) &#123;String&#125; pass Only logged in users can post this. * In generated documentation a separate * &quot;Login&quot; Block will be generated. * @apiParamExample &#123;json&#125; Request-Example1: * &#123; * &quot;id&quot;: 4711 * &#125; * @apiParamExample &#123;string&#125; Request-Example2: * &#123; * &quot;id&quot;: 4712 * &#125; */ @apiSampleRequest1@apiSampleRequest url 1234/** * @api &#123;get&#125; /user/:id * @apiSampleRequest http://api.github.com/some_path/ */ @apiSuccess1@apiSuccess [(group)] [&#123;type&#125;] field [description] 12345678/** * @api &#123;get&#125; /user/:id * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. * @apiSuccess &#123;Boolean&#123;true,false&#125;&#125; isInited 是否初始化 * @apiSuccess (200) &#123;Object&#125; firstname Firstname of the User1. * @apiSuccess (200) &#123;String&#125; firstname.lastname Lastname of the User1. */ @apiIgnore1@apiIgnore [hint] 1234/** * @api &#123;get&#125; /user/:id * @apiIgnore 该注释模块将不会被解析 */ @apiPrivate1@apiPrivate [hint] 1234/** * @api &#123;get&#125; /user/:id * @apiPrivate */","categories":[{"name":"apidoc","slug":"apidoc","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/apidoc/"}],"tags":[{"name":"apidoc","slug":"apidoc","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/apidoc/"}]},{"title":"4.3 手动实现一个深拷贝","slug":"4.3 手动实现一个深拷贝","date":"2017-09-29T15:15:50.000Z","updated":"2020-04-04T02:31:38.766Z","comments":true,"path":"2017/09/29/4.3 手动实现一个深拷贝/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/09/29/4.3 手动实现一个深拷贝/","excerpt":"","text":"第一种方式 JSON.parse(JSONS.string())JSON.parse(JSONS.string()) 第二种方式 Object.assign()Object.assign()可以实现简单对象的深拷贝，但是复杂深层对象只能浅拷贝 123456789var obj = &#123; name: &apos;tian&apos;, age: 18&#125;Object.assign(&#123;&#125;, obj)var noDeepCloneObj = &#123; &#125; 第三种方式 jquery$.extend({},obj)","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"4.2 Object.assign","slug":"4.2 Object.assign","date":"2017-09-12T13:36:52.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/09/12/4.2 Object.assign/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/09/12/4.2 Object.assign/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"4.1 解析赋值、浅拷贝、深拷贝","slug":"4.1 解析赋值、浅拷贝、深拷贝的区别","date":"2017-08-29T14:15:50.000Z","updated":"2020-04-01T14:38:21.542Z","comments":true,"path":"2017/08/29/4.1 解析赋值、浅拷贝、深拷贝的区别/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/08/29/4.1 解析赋值、浅拷贝、深拷贝的区别/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"3.4 bind的使用场景和实现","slug":"3.4 bind","date":"2017-08-25T01:15:50.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/08/25/3.4 bind/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/08/25/3.4 bind/","excerpt":"","text":"bind bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。bind返回的绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 bind 方法与 call / apply 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数。 var value = 2; var foo = { value: 1 }; function bar(name, age) { return { value: this.value, name: name, age: age } }; bar.call(foo, &quot;Jack&quot;, 20); // 直接执行了函数 // {value: 1, name: &quot;Jack&quot;, age: 20} var bindFoo1 = bar.bind(foo, &quot;Jack&quot;, 20); // 返回一个函数 bindFoo1(); // {value: 1, name: &quot;Jack&quot;, age: 20} var bindFoo2 = bar.bind(foo, &quot;Jack&quot;); // 返回一个函数 bindFoo2(20); // {value: 1, name: &quot;Jack&quot;, age: 20} bind的特性： 可以指定this 返回一个函数 可以传入参数 柯里化 使用场景业务场景var nickname = &quot;Kitty&quot;; function Person(name){ this.nickname = name; this.distractedGreeting = function() { setTimeout(function(){ console.log(&quot;Hello, my name is &quot; + this.nickname); }, 500); } } var person = new Person(&apos;jawil&apos;); person.distractedGreeting(); //Hello, my name is Kitty 这里输出的nickname是全局的，并不是我们创建 person 时传入的参数，因为 setTimeout 在全局环境中执行（不理解的查看【进阶3-1期】），所以 this 指向的是window。 这边把 setTimeout 换成异步回调也是一样的，比如接口请求回调。 方法1：var nickname = &quot;Kitty&quot;; function Person(name){ this.nickname = name; this.distractedGreeting = function() { var self = this; // added setTimeout(function(){ console.log(&quot;Hello, my name is &quot; + self.nickname); // changed }, 500); } } var person = new Person(&apos;jawil&apos;); person.distractedGreeting(); // Hello, my name is jawil 方法2：var nickname = &quot;Kitty&quot;; function Person(name){ this.nickname = name; this.distractedGreeting = function() { setTimeout(function(){ console.log(&quot;Hello, my name is &quot; + this.nickname); }.bind(this), 500); } } var person = new Person(&apos;jawil&apos;); person.distractedGreeting(); // Hello, my name is jawil 验证是否是数组var toStr = Function.prototype.call.bind(Object.prototype.toString); function isArray(obj){ return toStr(obj) === &apos;[object Array]&apos;; } isArray([1, 2, 3]); // true // 使用改造后的 toStr toStr([1, 2, 3]); // &quot;[object Array]&quot; toStr(&quot;123&quot;); // &quot;[object String]&quot; toStr(123); // &quot;[object Number]&quot; toStr(Object(123)); // &quot;[object Number]&quot; 上面方法首先使用 Function.prototype.call函数指定一个 this 值，然后 .bind 返回一个新的函数，始终将 Object.prototype.toString 设置为传入参数。其实等价于Object.prototype.toString.call() 。 这里有一个前提是toString()方法没有被覆盖 Object.prototype.toString = function() { return &apos;&apos;; } isArray([1, 2, 3]); // false 柯里化 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 可以一次性地调用柯里化函数，也可以每次只传一个参数分多次调用。 var add = function(x) { return function(y) { return x + y; }; }; var increment = add(1); var addTen = add(10); increment(2); // 3 addTen(2); // 12 add(1)(2); // 3 这里定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。所以说 bind 本身也是闭包的一种使用场景。 模拟实现bind（） 函数在 ES5 才被加入，所以并不是所有浏览器都支持，IE8及以下的版本中不被支持，如果需要兼容可以使用 Polyfill 来实现。 可以指定this 返回一个函数 可以传入参数 柯里化 step1Function.prototype.bind2 = function(context) { var self = this; // this 指向调用者 return function () { // 实现第 2点 return self.apply(context); // 实现第 1 点 } } // 测试用例 var value = 2; var foo = { value: 1 }; function bar() { return this.value; } var bindFoo = bar.bind2(foo); bindFoo(); // 1 step2对于第 3 点，使用 arguments 获取参数数组并作为 self.apply() 的第二个参数。 对于第 4 点，获取返回函数的参数，然后同第3点的参数合并成一个参数数组，并作为 self.apply() 的第二个参数。 // 第二版 Function.prototype.bind2 = function (context) { var self = this; // 实现第3点，因为第1个参数是指定的this,所以只截取第1个之后的参数 // arr.slice(begin); 即 [begin, end] var args = Array.prototype.slice.call(arguments, 1); return function () { // 实现第4点，这时的arguments是指bind返回的函数传入的参数 // 即 return function 的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply( context, args.concat(bindArgs) ); } } // 测试用例 var value = 2; var foo = { value: 1 }; function bar(name, age) { return { value: this.value, name: name, age: age } }; var bindFoo = bar.bind2(foo, &quot;Jack&quot;); bindFoo(20); // {value: 1, name: &quot;Jack&quot;, age: 20} step3 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 var value = 2; var foo = { value: 1 }; function bar(name, age) { this.habit = &apos;shopping&apos;; console.log(this.value); console.log(name); console.log(age); } bar.prototype.friend = &apos;kevin&apos;; var bindFoo = bar.bind(foo, &apos;Jack&apos;); var obj = new bindFoo(20); // undefined // Jack // 20 obj.habit; // shopping obj.friend; // kevin 上面例子中，运行结果this.value 输出为 undefined，这不是全局value 也不是foo对象中的value，这说明 bind 的 this 对象失效了，new 的实现中生成一个新的对象，这个时候的 this指向的是 obj // 第三版 Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); // 注释1 return self.apply( this instanceof fBound ? this : context, args.concat(bindArgs) ); } // 注释2 fBound.prototype = this.prototype; return fBound; } 注释1： 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context 注释2： 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。 step4上面实现中 fBound.prototype = this.prototype有一个缺点，直接修改 fBound.prototype 的时候，也会直接修改 this.prototype。 // 测试用例 var value = 2; var foo = { value: 1 }; function bar(name, age) { this.habit = &apos;shopping&apos;; console.log(this.value); console.log(name); console.log(age); } bar.prototype.friend = &apos;kevin&apos;; var bindFoo = bar.bind2(foo, &apos;Jack&apos;); // bind2 var obj = new bindFoo(20); // 返回正确 // undefined // Jack // 20 obj.habit; // 返回正确 // shopping obj.friend; // 返回正确 // kevin obj.__proto__.friend = &quot;Kitty&quot;; // 修改原型 bar.prototype.friend; // 返回错误，这里被修改了 // Kitty // 第四版，已通过测试用例 Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); return self.apply( this instanceof fNOP ? this : context, args.concat(bindArgs) ); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; } step5但有一个问题是调用 bind 的不是函数，这时候需要抛出异常。 // 第五版 Function.prototype.bind2 = function (context) { if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; }","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"3.5 new","slug":"3.5 new","date":"2017-08-21T12:15:50.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/08/21/3.5 new/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/08/21/3.5 new/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"3.3 call和apply","slug":"3.3 call和apply","date":"2017-08-20T23:15:50.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/08/21/3.3 call和apply/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/08/21/3.3 call和apply/","excerpt":"","text":"call() 和 apply() call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 call() 和 apply()的区别在于，call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组 var func = function(arg1, arg2) { ... }; ca func.ll(this, arg1, arg2); // 使用 call，参数列表 func.apply(this, [arg1, arg2]) // 使用 apply，参数数组 使用场景下面列举一些常用用法： 1、合并两个数组var vegetables = [&apos;parsnip&apos;, &apos;potato&apos;]; var moreVegs = [&apos;celery&apos;, &apos;beetroot&apos;]; // 将第二个数组融合进第一个数组 // 相当于 vegetables.push(&apos;celery&apos;, &apos;beetroot&apos;); Array.prototype.push.apply(vegetables, moreVegs); // 4 vegetables; // [&apos;parsnip&apos;, &apos;potato&apos;, &apos;celery&apos;, &apos;beetroot&apos;] 当第二个数组(如示例中的 moreVegs )太大时不要使用这个方法来合并数组，因为一个函数能够接受的参数个数是有限制的。不同的引擎有不同的限制，JS核心限制在 65535，有些引擎会抛出异常，有些不抛出异常但丢失多余参数。 function concatOfArray(arr1, arr2) { var QUANTUM = 32768; for (var i = 0, len = arr2.length; i &lt; len; i += QUANTUM) { Array.prototype.push.apply( arr1, arr2.slice(i, Math.min(i + QUANTUM, len) ) ); } return arr1; } // 验证代码 var arr1 = [-3, -2, -1]; var arr2 = []; for(var i = 0; i &lt; 1000000; i++) { arr2.push(i); } Array.prototype.push.apply(arr1, arr2); // Uncaught RangeError: Maximum call stack size exceeded concatOfArray(arr1, arr2); // (1000003) [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...] 2. 获取数组中的最大值和最小值1. //最小值 Array.prototype.min = function() { var min = this[0]; var len = this.length; for (var i = 1; i &lt; len; i++){ if (this[i] &lt; min){ min = this[i]; } } return min; } //最大值 Array.prototype.max = function() { var max = this[0]; var len = this.length; for (var i = 1; i &lt; len; i++){ if (this[i] &gt; max) { max = this[i]; } } return max; } 2. var numbers = [1, 2, 5, 5, 9, 12]; Math.max.apply(Math, numbers); Math.max.call(Math, numbers); 3 Array.prototype.max = function(){ return Math.max.apply({},this) } Array.prototype.min = function(){ return Math.min.apply({},this) } [1,2,3].max()// =&gt; 3 [1,2,3].min()// =&gt; 1 4 var a=[1,2,3,5]; alert(Math.max.apply(null, a));//最大值 alert(Math.min.apply(null, a));//最小值 多维数组可以这么修改： var a=[1,2,3,[5,6],[1,4,8]]; var ta=a.join(&quot;,&quot;).split(&quot;,&quot;);//转化为一维数组 alert(Math.max.apply(null,ta));//最大值 alert(Math.min.apply(null,ta));//最小值 为什么要这么用呢，因为数组 numbers 本身没有 max方法，但是 Math有呀，所以这里就是借助 call / apply 使用 Math.max 方法。 验证是否是数组function isArray(obj){ return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;; } isArray([1, 2, 3]); // true // 直接使用 toString() [1, 2, 3].toString(); // &quot;1,2,3&quot; &quot;123&quot;.toString(); // &quot;123&quot; 123.toString(); // SyntaxError: Invalid or unexpected token Number(123).toString(); // &quot;123&quot; Object(123).toString(); // &quot;123&quot; 可以通过toString() 来获取每个对象的类型，但是不同对象的 toString()有不同的实现，所以通过 Object.prototype.toString() 来检测，需要以 call() / apply() 的形式来调用，传递要检查的对象作为第一个参数。 var toStr = Function.prototype.call.bind(Object.prototype.toString); function isArray(obj){ return toStr(obj) === &apos;[object Array]&apos;; } isArray([1, 2, 3]); // true // 使用改造后的 toStr toStr([1, 2, 3]); // &quot;[object Array]&quot; toStr(&quot;123&quot;); // &quot;[object String]&quot; toStr(123); // &quot;[object Number]&quot; toStr(Object(123)); // &quot;[object Number]&quot; 上面方法首先使用 Function.prototype.call函数指定一个 this 值，然后 .bind 返回一个新的函数，始终将 Object.prototype.toString 设置为传入参数。其实等价于 Object.prototype.toString.call() 。 类数组对象（Array-like Object）使用数组方法类数组对象有下面两个特性 1、具有：指向对象元素的数字索引下标和 length 属性 2、不具有：比如 push 、shift、 forEach 以及 indexOf等数组对象具有的方法 要说明的是，类数组对象是一个对象。JS中存在一种名为类数组的对象结构，比如 arguments 对象，还有DOM API 返回的 NodeList 对象都属于类数组对象，类数组对象不能使用 push/pop/shift/unshift 等数组方法，通过 Array.prototype.slice.call 转换成真正的数组，就可以使用 Array下所有方法。 // 上面代码等同于 var arr = [].slice.call(arguments)； ES6: let arr = Array.from(arguments); let arr = [...arguments]; Array.from() 可以将两类对象转为真正的数组：类数组对象和可遍历（iterable）对象（包括ES6新增的数据结构 Set 和 Map） 调用父构造函数实现继承function SuperType(){ this.color=[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; } function SubType(){ // 核心代码，继承自SuperType SuperType.call(this); } var instance1 = new SubType(); instance1.color.push(&quot;black&quot;); console.log(instance1.color); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;] var instance2 = new SubType(); console.log(instance2.color); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] call和apply的模拟实现举个栗子： var value = 1; var foo = { value: 1 }; function bar() { console.log(this.value); } bar.call(foo); // 1 通过上面的介绍我们知道，call()主要有以下两点： 1、call()改变了this的指向 2、函数 bar 执行了 step1如果在调用call()的时候把函数 bar()添加到foo()对象中，即如下： var foo = { value: 1, bar: function() { console.log(this.value); }}; foo.bar(); // 1 这个改动就可以实现：改变了this的指向并且执行了函数bar。但是这样写是有副作用的，即给foo额外添加了一个属性，怎么解决呢？解决方法很简单，用 delete 删掉就好了。所以只要实现下面3步就可以模拟实现了。 1、将函数设置为对象的属性：foo.fn = bar2、执行函数：foo.fn()3、删除函数：delete foo.fn Function.prototype.call2 = function (context) { //this -&gt; bar context.Fn = this; context.Fn(); delete context.Fn; }; var foo = { value: &apos;tian&apos; }; var value = &apos;tian/g&apos;; function bar() { console.log(this.value); }; bar.call2(foo); step31、this 参数可以传 null 或者 undefined，此时 this 指向 window 2、this 参数可以传基本类型数据，原生的 call 会自动用 Object() 转换 3、函数是可以有返回值的 Function.prototype.call2 = function (context) { context = context ? Object(context) : window; // 实现细节 1 和 2 context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;); delete context.fn return result; // 实现细节 2 } // 测试一下 var value = 2; var obj = { value: 1 } function bar(name, age) { console.log(this.value); return { value: this.value, name: name, age: age } } function foo() { console.log(this); } bar.call2(null); // 2 foo.call2(123); // Number {123, fn: ƒ} bar.call2(obj, &apos;kevin&apos;, 18); // 1 // { // value: 1, // name: &apos;kevin&apos;, // age: 18 // } 总结：call的模拟实现Function.prototype.call = function (context) { context = context ? Object(context) : window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;); delete context.fn return result; } Function.prototype.call = function (context) { context = context ? Object(context) : window; context.fn = this; let args = [...arguments].slice(1); let result = context.fn(...args); delete context.fn return result; } apply的模拟实现Function.prototype.apply = function (context, arr) { context = context ? Object(context) : window; context.fn = this; var result; // 判断是否存在第二个参数 if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) { args.push(&apos;arr[&apos; + i + &apos;]&apos;); } result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;); } delete context.fn return result; } Function.prototype.apply = function (context, arr) { context = context ? Object(context) : window; context.fn = this; let result; if (!arr) { result = context.fn(); } else { result = context.fn(...arr); } delete context.fn return result; }","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"3.2 理解箭头函数中this","slug":"3.2 理解箭头函数中this","date":"2017-07-29T12:15:50.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/07/29/3.2 理解箭头函数中this/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/07/29/3.2 理解箭头函数中this/","excerpt":"","text":"箭头函数的this： 箭头函数不绑定this，箭头函数中的this相当于一个变量 箭头函数中this寻值行为与普通变量相同，在作用域中逐级寻找 箭头函数的this无法通过bind，call，apply来直接进行修改（可以通过改变箭头函数所在执行上下文的this进行间接修改，eg1） 改变作用域中的this指向可以改变箭头函数的this（eg1） eg1： function closure(){()=&gt;{//code }}，在此例中，我们通过改变封包环境closure.bind(another)()，来改变箭头函数this的指向。 /** * 非严格模式 */ var name = &apos;window&apos; var person1 = { name: &apos;person1&apos;, show1: function () { console.log(this.name) }, show2: () =&gt; console.log(this.name), show3: function () { return function () { console.log(this.name) } }, show4: function () { return () =&gt; console.log(this.name) } } var person2 = { name: &apos;person2&apos; } person1.show1() person1.show1.call(person2) person1.show2() person1.show2.call(person2) person1.show3()() person1.show3().call(person2) person1.show3.call(person2)() person1.show4()() person1.show4().call(person2) person1.show4.call(person2)() 结果： person1.show1() // person1，隐式绑定，this指向调用者 person1 person1.show1.call(person2) // person2，显式绑定，this指向 person2 person1.show2() // window，箭头函数绑定，this指向外层作用域，即全局作用域 person1.show2.call(person2) // window，箭头函数绑定，this指向外层作用域，即全局作用域 person1.show3()() // window，默认绑定，这是一个高阶函数，调用者是window // 类似于`var func = person1.show3()` 执行`func()` person1.show3().call(person2) // person2，显式绑定，this指向 person2 person1.show3.call(person2)() // window，默认绑定，调用者是window person1.show4()() // person1，箭头函数绑定，this指向外层作用域，即person1函数作用域 person1.show4().call(person2) // person1，箭头函数绑定， // this指向外层作用域，即person1函数作用域 person1.show4.call(person2)() // person2 最后一个person1.show4.call(person2)()有点复杂，我们来一层一层的剥开。 1、首先是var func1 = person1.show4.call(person2)，这是显式绑定，调用者是person2，show4函数指向的是person2。2、然后是func1()，箭头函数绑定，this指向外层作用域，即person2函数作用域 首先要说明的是，箭头函数绑定中，this指向外层作用域，并不一定是第一层，也不一定是第二层。因为没有自身的this，所以只能根据作用域链往上层查找，直到找到一个绑定了this的函数作用域，并指向调用该普通函数的对象 /** * 非严格模式 */ var name = &apos;window&apos; function Person (name) { this.name = name; this.show1 = function () { console.log(this.name) } this.show2 = () =&gt; console.log(this.name) this.show3 = function () { return function () { console.log(this.name) } } this.show4 = function () { return () =&gt; console.log(this.name) } } var personA = new Person(&apos;personA&apos;) var personB = new Person(&apos;personB&apos;) personA.show1() personA.show1.call(personB) personA.show2() personA.show2.call(personB) personA.show3()() personA.show3().call(personB) personA.show3.call(personB)() personA.show4()() personA.show4().call(personB) personA.show4.call(personB)() 结果： personA.show1() // personA，隐式绑定，调用者是 personA personA.show1.call(personB) // personB，显式绑定，调用者是 personB personA.show2() // personA，首先personA是new绑定，产生了新的构造函数作用域， // 然后是箭头函数绑定，this指向外层作用域，即personA函数作用域 personA.show2.call(personB) // personA，同上 personA.show3()() // window，默认绑定，调用者是window personA.show3().call(personB) // personB，显式绑定，调用者是personB personA.show3.call(personB)() // window，默认绑定，调用者是window personA.show4()() // personA，箭头函数绑定，this指向外层作用域，即personA函数作用域 personA.show4().call(personB) // personA，箭头函数绑定，call并没有改变外层作用域， // this指向外层作用域，即personA函数作用域 personA.show4.call(personB)() // personB，解析同题目1，最后是箭头函数绑定， // this指向外层作用域，即改变后的person2函数作用域 总结： 使用 new 操作符调用构造函数，实际上会经历一下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"3.1 this的绑定方式","date":"2017-07-19T01:15:50.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/07/19/3.1 this的绑定方式/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/07/19/3.1 this的绑定方式/","excerpt":"","text":"this的绑定： 默认绑定 隐式绑定 显式绑定 new绑定 箭头函数绑定 调用位置调用位置就是函数在代码中被调用的位置（而不是声明的位置） 绑定规则默认绑定 独立函数的调用：this -&gt; window 严格模式下，不能讲全局对象用于默认绑定，this会绑定到undefined.只有函数在非严格模式下，默认绑定才绑定到window上。 function foo() { // 运行在严格模式下，this会绑定到undefined &quot;use strict&quot;; console.log( this.a ); } var a = 2; // 调用 foo(); // TypeError: Cannot read property &apos;a&apos; of undefined // -------------------------------------- function foo() { // 运行 console.log( this.a ); } var a = 2; (function() { // 严格模式下调用函数则不影响默认绑定 &quot;use strict&quot;; foo(); // 2 })(); 隐式绑定function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj 对象。 然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它 无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj ，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置，举例来说： function foo() { console.log( this.a ); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42 隐式丢失一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名！ var a = &quot;oops, global&quot;; // a 是全局对象的属性 bar(); // &quot;oops, global&quot; 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时: function foo() { console.log( this.a ); } function doFoo(fn) { // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！ } var obj = { a: 2, foo: foo }; var a = &quot;oops, global&quot;; // a 是全局对象的属性 doFoo( obj.foo ); // &quot;oops, global&quot; 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样 如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别： function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var a = &quot;oops, global&quot;; // a 是全局对象的属性 setTimeout( obj.foo, 100 ); // &quot;oops, global&quot; JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似： function setTimeout(fn,delay) { // 等待 delay 毫秒 fn(); // &lt;-- 调用位置！ } 显式绑定（call/apply）在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？ JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关——之后我们会详细介绍原型），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。 call()和apply()的第一个参数是一个对象，他们会把这个对象绑定到this，在函数调用时指定这个this就是第一个参数对象，因为可以直接指定this的绑定对象，所以叫做显式绑定。 function foo() { console.log( this.a ); } var obj = { a:2 }; foo.call( obj ); // 2 通过foo.call(obj), 我们在调用foo时会把他的this指定到obj对象。 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..) 、 new Boolean(..) 或者new Number(..) ）。这通常被称为“装箱” 硬绑定解决我们之前提出的丢失绑定问题。 function foo() { console.log( this.a ); } var obj = { a:2 }; var bar = function() { foo.call( obj ); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this bar.call( window ); // 2 我们来看看这个变种到底是怎样工作的。我们创建了函数 bar() ，并在它的内部手动调用了 foo.call(obj) ，因此强制把 foo 的 this 绑定到了 obj 。无论之后如何调用函数 bar ，它总会手动在 obj 上调用 foo 。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。 硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值： function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a:2 }; var bar = function() { return foo.apply( obj, arguments ); }; var b = bar( 3 ); // 2 3 console.log( b ); // 5 另一种使用方法是创建一个 i 可以重复使用的辅助函数 function foo(something) { console.log( this.a, something ); return this.a + something; } // 简单的辅助绑定函数 function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); }; } var obj = { a:2 }; var bar = bind( foo, obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。 API调用的上下文第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this 。 function foo(el) { console.log( el, this.id ); } var obj = { id: &quot;awesome&quot; }; // 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome 这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些代码。 new绑定这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 JavaScript 中函数和对象的误解。 在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的： something = new MyClass(..); JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。 首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。 举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它： 当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。 所以，包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。5我们现在关心的是第 1 步、第 3 步、第 4 步，所以暂时跳过第 2 步，第 5 章会详细介绍它。 思考下面的代码： function foo(a) { this.a = a; } var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。 new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 参考：你不知道的javascript","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"2.2 从作用域链的角度看闭包","slug":"2.2 从作用域的角度看闭包","date":"2017-06-17T11:25:50.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/06/17/2.2 从作用域的角度看闭包/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/06/17/2.2 从作用域的角度看闭包/","excerpt":"","text":"首先我们来看一个函数： var scope = &quot;global scope&quot;; function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f; } var foo = checkscope(); // foo指向函数f foo(); // 调用函数f() 执行过程 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 函数f执行的时候，checkscope函数执行上下文已经被销毁，那么f函数怎么访问到scope变量呢？ 函数f 执行上下文维护了一个作用域链，会指向指向checkscope作用域 所以指向关系是当前作用域 –&gt; checkscope作用域–&gt; 全局作用域，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，这就是闭包实现的关键。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"2.1 理解闭包","slug":"2.1 闭包的作用和优缺点","date":"2017-06-13T11:14:20.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/06/13/2.1 闭包的作用和优缺点/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/06/13/2.1 闭包的作用和优缺点/","excerpt":"","text":"什么是闭包？闭包的优缺点？ 闭包（closure）是javascript的一大难点，也是它的特色。很多高级应用都要依靠闭包来实现。 变量作用域要理解闭包，首先要理解javascript的特殊的变量作用域。 变量的作用域无非就两种：全局变量和局部变量。 javascript语言的特别之处就在于： 函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ 如何从外部读取函数内部的局部变量？出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。 那就是在函数内部，再定义一个函数。 function f1(){ var n=999; function f2(){ alert(n); // 999 } } 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 这就是Javascript语言特有的”链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包的用途闭包可以用在许多地方。它的最大用处有两个， 一个是前面提到的可以读取函数内部的变量 另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"1.5 内存泄漏如何避免","slug":"1.5 内存泄漏如何避免","date":"2017-05-29T13:34:20.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/05/29/1.5 内存泄漏如何避免/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/05/29/1.5 内存泄漏如何避免/","excerpt":"","text":"垃圾回收算法常用垃圾回收算法叫做标记清除 （Mark-and-sweep） ，算法由以下几步组成： 垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾） 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。 本质：可达内存被标记，其余的被当作垃圾回收 四种常见的JS内存泄漏意外的全局变量1 function foo(arg) { bar = &quot;this is a hidden global variable&quot;; } 函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。 2 function foo() { this.variable = &quot;potential accidental global&quot;; } // Foo 调用自己，this 指向了全局对象（window） // 而不是 undefined foo(); 解决方法：使用’use strict’ 被遗忘的计时器或回调函数var someResource = getData(); setInterval(function() { var node = document.getElementById(&apos;Node&apos;); if(node) { // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); } }, 1000); 在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。 var element = document.getElementById(&apos;button&apos;); function onClick(event) { element.innerHTML = &apos;text&apos;; } element.addEventListener(&apos;click&apos;, onClick); 对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。 脱离 DOM 的引用如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。 var elements = { button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;) }; function doStuff() { image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑 } function removeButton() { // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 } 闭包var theThing = null; var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) console.log(&quot;hi&quot;); }; theThing = { longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () { console.log(someMessage); } }; }; setInterval(replaceThing, 1000); 每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。 解决方法：在 replaceThing 的最后添加 originalThing = null 。 问题 从内存来看 null 和 undefined 本质的区别是什么？ 给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值 ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？ const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: “foo” is read-only const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"1.4 内存机制","slug":"1.4 内存机制","date":"2017-05-22T11:11:20.000Z","updated":"2020-04-01T14:38:21.540Z","comments":true,"path":"2017/05/22/1.4 内存机制/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/05/22/1.4 内存机制/","excerpt":"","text":"JS内存空间栈内存（stack）：存放变量 堆内存（heap）：存放复杂对象 池（一般也归类栈中）：存放常量 function A() { let a = 1 function B() { console.log(a) } return B } 闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量内存回收js有自动垃圾回收机制，垃圾收集器会每个一段时间就执行一次释放操作，找出那些不在继续使用的值，然后释放其占用的内存。 局部变量和全局变量的销毁 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量 以Google的V8引擎为例，V8引擎中的所有的JS独享都是通过对来金鹰内粗分配的 初始分配：声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止 V8引擎对堆内存中的JS对象进行分代管理 新生代：存活周期较短的JS对象，如临时变量、字符串等。老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。 垃圾回收算法对垃圾回收算法来说，核心思想就是如何判断内存已经不使用了，常用垃圾回收算法： 引用计数（现在浏览器不再使用） 标记清除 引用计数引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。 // 创建一个对象person，他有两个指向属性age和name的引用 var person = { age: 12, name: &apos;aaaa&apos; }; person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收 var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收 p = null; //原person对象已经没有引用，很快会被回收 引用计数有一个致命问题就是循环引用 cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。 function cycle() { var o1 = {}; var o2 = {}; o1.a = o2; o2.a = o1; return &quot;cycle reference!&quot; } cycle(); 如果两个对象相互引用，尽管他们已经不在使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。 标记清除标记清除将“将不再使用的队形”定义为无法到达的对象。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。 对于主流浏览器来说，只需要切断需要回收的对象与根部的联系，就可以被垃圾回收机制回收 email.message = document.createElement(“div”); displayList.appendChild(email.message); // 稍后从displayList中清除DOM元素 displayList.removeAllChildren(); 上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。 内存泄漏对于持续与逆行的服务进程，必须及时释放不在用到的内存废旧则内存占用的越来越高，轻则影响到系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就叫做内存泄漏。 内存泄漏识别方法 谷歌浏览器：Memory -&gt; Select profiling -&gt; timeline -&gt; start -&gt; stop node process.memoryUsage WeakMapES6新的数据结构 WeakSet 和 WeakMap，表示这是弱引用，他们对于值的引用都是不计入垃圾回收机制的 const wm = new WeakMap(); const element = document.getElementById(&apos;example&apos;); wm.set(element, &apos;some information&apos;); wm.get(element) // &quot;some information&quot; 先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"1.3 栈堆队列理解","slug":"1.3 栈堆队列理解","date":"2017-05-15T01:11:48.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/05/15/1.3 栈堆队列理解/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/05/15/1.3 栈堆队列理解/","excerpt":"","text":"栈数据结构后进先出（LIFO） 堆数据结构堆是一种树状结构，存取类似于图书馆 队列队列是一种先进先出（FIFO）的数据结构 变量的存放 基本数据类型：保存在栈内存中，因为这些数据类型在内存中占有固定大小的空间，按值访问。 注： undefined null Boolean Number String Symbol 引用数据类型：保存在堆内存中，因为这种值大小不固定，但是内存地址（因为大小固定）保存在堆内存中；在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。 内存管理空间 分配你所需要的内存 使用分配到的内存 不需要时释放 归还 JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。 ！！！赋值语句的执行顺序是从右至左 var a = {n: 1}; var b = a; a.x = a = {n: 2}; a.x // 这时 a.x 的值是多少 b.x // 这时 b.x 的值是多少","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"1.2 执行上下文栈和变量对象","slug":"1.2 执行上下文栈和变量对象","date":"2017-05-06T12:11:48.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/05/06/1.2 执行上下文栈和变量对象/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/05/06/1.2 执行上下文栈和变量对象/","excerpt":"","text":"变量提升： foo; // undefined var foo = function () { console.log(&apos;foo1&apos;); } foo(); // foo1，foo赋值 var foo = function () { console.log(&apos;foo2&apos;); } foo(); // foo2，foo重新赋值 函数提升： foo(); // foo2 function foo() { console.log(&apos;foo1&apos;); } foo(); // foo2 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo2 变量提升和函数提升优先级： foo(); // foo2 var foo = function() { console.log(&apos;foo1&apos;); } foo(); // foo1，foo重新赋值 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo1 执行上下文栈 JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。 函数上下文 在函数上下文中，用活动对象(activation object, AO)来表示变量对象。活动对象和变量对象的区别在于 1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。 2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问 执行过程 进入执行上下文 1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。 2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。 3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。 function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 代码执行 AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression &quot;d&quot; } 总结 1、全局上下文的变量对象初始化是全局对象 2、函数上下文的变量对象初始化只包括 Arguments 对象 3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 4、在代码执行阶段，会再次修改变量对象的属性值","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"}]},{"title":"1.1 执行上下文栈","slug":"1.1 执行上下文栈","date":"2017-04-29T12:31:48.000Z","updated":"2020-04-01T14:38:21.541Z","comments":true,"path":"2017/04/29/1.1 执行上下文栈/","link":"","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/2017/04/29/1.1 执行上下文栈/","excerpt":"","text":"执行上下文：当前javascript代码被解析和执行所在环境的抽象概念 执行上下文类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象 函数执行上下文：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文 Eval执行上下文: eval()函数中的代码,很少用而且不建议使用 执行栈:也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 var a = &apos;1&apos;; function first() { console.log(&apos;Inside first function&apos;); second(); console.log(&apos;Again inside first function&apos;); } function second() { console.log(&apos;Inside second function&apos;); } first(); console.log(&apos;Inside Global Execution Context&apos;); // Inside first function // Inside second function // Again inside first function // Inside Global Execution Context 执行上下文的创建:执行上下文的创建分为两个阶段： 1）创建阶段2）执行阶段 创建阶段 确定this 全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象 创建词法环境 （全局环境和函数环境） 环境记录：存储变量和函数声明的实际位置 对外部环境的访问：访问外部词法环境 创建变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 执行阶段所有变量的分配，最后执行代码。 注： 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/js/"},{"name":"执行栈","slug":"执行栈","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/执行栈/"},{"name":"执行上下文","slug":"执行上下文","permalink":"http://tianxianseng.xn--qiv13xrkb.xn--ses554g/tags/执行上下文/"}]}]}