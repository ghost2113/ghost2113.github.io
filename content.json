{"meta":{"title":"让优秀成为一种习惯","subtitle":null,"description":"无数青山隔沧海,与谁同往却同归","author":"Mr.Tian","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-04-29T15:08:45.000Z","updated":"2019-04-29T15:16:56.679Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-16T12:31:48.000Z","updated":"2019-04-16T13:12:22.487Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-16T13:16:12.000Z","updated":"2019-04-16T13:21:33.365Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"1.2 执行上下文栈和变量对象","slug":"js学习笔记/1.2执行上下文栈和变量对象","date":"2017-05-06T12:11:48.000Z","updated":"2019-05-06T14:59:10.977Z","comments":true,"path":"2017/05/06/js学习笔记/1.2执行上下文栈和变量对象/","link":"","permalink":"http://yoursite.com/2017/05/06/js学习笔记/1.2执行上下文栈和变量对象/","excerpt":"","text":"变量提升： foo; // undefined var foo = function () { console.log(&apos;foo1&apos;); } foo(); // foo1，foo赋值 var foo = function () { console.log(&apos;foo2&apos;); } foo(); // foo2，foo重新赋值 函数提升： foo(); // foo2 function foo() { console.log(&apos;foo1&apos;); } foo(); // foo2 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo2 变量提升和函数提升优先级： foo(); // foo2 var foo = function() { console.log(&apos;foo1&apos;); } foo(); // foo1，foo重新赋值 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo1 执行上下文栈 JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。 函数上下文 在函数上下文中，用活动对象(activation object, AO)来表示变量对象。活动对象和变量对象的区别在于 1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。 2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问 执行过程 进入执行上下文 1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。 2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。 3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。 function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 代码执行 AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression &quot;d&quot; } 总结 1、全局上下文的变量对象初始化是全局对象 2、函数上下文的变量对象初始化只包括 Arguments 对象 3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 4、在代码执行阶段，会再次修改变量对象的属性值","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.1 执行上下文栈","slug":"js学习笔记/1.1执行上下文栈","date":"2017-04-29T12:31:48.000Z","updated":"2019-05-06T14:29:21.930Z","comments":true,"path":"2017/04/29/js学习笔记/1.1执行上下文栈/","link":"","permalink":"http://yoursite.com/2017/04/29/js学习笔记/1.1执行上下文栈/","excerpt":"","text":"执行上下文：当前javascript代码被解析和执行所在环境的抽象概念 执行上下文类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象 函数执行上下文：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文 Eval执行上下文: eval()函数中的代码,很少用而且不建议使用 执行栈:也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 var a = &apos;1&apos;; function first() { console.log(&apos;Inside first function&apos;); second(); console.log(&apos;Again inside first function&apos;); } function second() { console.log(&apos;Inside second function&apos;); } first(); console.log(&apos;Inside Global Execution Context&apos;); // Inside first function // Inside second function // Again inside first function // Inside Global Execution Context 执行上下文的创建:执行上下文的创建分为两个阶段： 1）创建阶段2）执行阶段 创建阶段 确定this 全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象 创建词法环境 （全局环境和函数环境） 环境记录：存储变量和函数声明的实际位置 对外部环境的访问：访问外部词法环境 创建变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 执行阶段所有变量的分配，最后执行代码。 注： 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"执行栈","slug":"执行栈","permalink":"http://yoursite.com/tags/执行栈/"},{"name":"执行上下文","slug":"执行上下文","permalink":"http://yoursite.com/tags/执行上下文/"}]}]}