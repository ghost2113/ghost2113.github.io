{"meta":{"title":"让优秀成为一种习惯","subtitle":null,"description":"无数青山隔沧海,与谁同往却同归","author":"Mr.Tian","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-04-16T12:31:48.000Z","updated":"2019-04-16T13:12:22.487Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-04-29T15:08:45.000Z","updated":"2019-04-29T15:16:56.679Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-16T13:16:12.000Z","updated":"2019-04-16T13:21:33.365Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"1.5 内存泄漏如何避免","slug":"js学习笔记/1.5 内存泄漏如何避免","date":"2017-05-29T13:34:20.000Z","updated":"2019-05-08T15:42:22.852Z","comments":true,"path":"2017/05/29/js学习笔记/1.5 内存泄漏如何避免/","link":"","permalink":"http://yoursite.com/2017/05/29/js学习笔记/1.5 内存泄漏如何避免/","excerpt":"","text":"垃圾回收算法常用垃圾回收算法叫做标记清除 （Mark-and-sweep） ，算法由以下几步组成： 垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾） 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。 本质：可达内存被标记，其余的被当作垃圾回收 四种常见的JS内存泄漏意外的全局变量1 function foo(arg) { bar = &quot;this is a hidden global variable&quot;; } 函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。 2 function foo() { this.variable = &quot;potential accidental global&quot;; } // Foo 调用自己，this 指向了全局对象（window） // 而不是 undefined foo(); 解决方法：使用’use strict’ 被遗忘的计时器或回调函数var someResource = getData(); setInterval(function() { var node = document.getElementById(&apos;Node&apos;); if(node) { // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); } }, 1000); 在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。 var element = document.getElementById(&apos;button&apos;); function onClick(event) { element.innerHTML = &apos;text&apos;; } element.addEventListener(&apos;click&apos;, onClick); 对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。 脱离 DOM 的引用如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。 var elements = { button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;) }; function doStuff() { image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑 } function removeButton() { // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 } 闭包var theThing = null; var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) console.log(&quot;hi&quot;); }; theThing = { longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () { console.log(someMessage); } }; }; setInterval(replaceThing, 1000); 每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。 解决方法：在 replaceThing 的最后添加 originalThing = null 。 问题 从内存来看 null 和 undefined 本质的区别是什么？ 给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值 ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？ const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: “foo” is read-only const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.4 内存机制","slug":"js学习笔记/1.4 内存机制","date":"2017-05-22T11:11:20.000Z","updated":"2019-05-08T14:44:25.246Z","comments":true,"path":"2017/05/22/js学习笔记/1.4 内存机制/","link":"","permalink":"http://yoursite.com/2017/05/22/js学习笔记/1.4 内存机制/","excerpt":"","text":"JS内存空间栈内存（stack）：存放变量 堆内存（heap）：存放复杂对象 池（一般也归类栈中）：存放常量 function A() { let a = 1 function B() { console.log(a) } return B } 闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量内存回收js有自动垃圾回收机制，垃圾收集器会每个一段时间就执行一次释放操作，找出那些不在继续使用的值，然后释放其占用的内存。 局部变量和全局变量的销毁 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量 以Google的V8引擎为例，V8引擎中的所有的JS独享都是通过对来金鹰内粗分配的 初始分配：声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止 V8引擎对堆内存中的JS对象进行分代管理 新生代：存活周期较短的JS对象，如临时变量、字符串等。老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。 垃圾回收算法对垃圾回收算法来说，核心思想就是如何判断内存已经不使用了，常用垃圾回收算法： 引用计数（现在浏览器不再使用） 标记清除 引用计数引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。 // 创建一个对象person，他有两个指向属性age和name的引用 var person = { age: 12, name: &apos;aaaa&apos; }; person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收 var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收 p = null; //原person对象已经没有引用，很快会被回收 引用计数有一个致命问题就是循环引用 cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。 function cycle() { var o1 = {}; var o2 = {}; o1.a = o2; o2.a = o1; return &quot;cycle reference!&quot; } cycle(); 如果两个对象相互引用，尽管他们已经不在使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。 标记清除标记清除将“将不再使用的队形”定义为无法到达的对象。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。 对于主流浏览器来说，只需要切断需要回收的对象与根部的联系，就可以被垃圾回收机制回收 email.message = document.createElement(“div”); displayList.appendChild(email.message); // 稍后从displayList中清除DOM元素 displayList.removeAllChildren(); 上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。 内存泄漏对于持续与逆行的服务进程，必须及时释放不在用到的内存废旧则内存占用的越来越高，轻则影响到系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就叫做内存泄漏。 内存泄漏识别方法 谷歌浏览器：Memory -&gt; Select profiling -&gt; timeline -&gt; start -&gt; stop node process.memoryUsage WeakMapES6新的数据结构 WeakSet 和 WeakMap，表示这是弱引用，他们对于值的引用都是不计入垃圾回收机制的 const wm = new WeakMap(); const element = document.getElementById(&apos;example&apos;); wm.set(element, &apos;some information&apos;); wm.get(element) // &quot;some information&quot; 先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.3 栈堆队列理解","slug":"js学习笔记/1.3 栈堆队列理解","date":"2017-05-15T01:11:48.000Z","updated":"2019-05-06T15:27:41.041Z","comments":true,"path":"2017/05/15/js学习笔记/1.3 栈堆队列理解/","link":"","permalink":"http://yoursite.com/2017/05/15/js学习笔记/1.3 栈堆队列理解/","excerpt":"","text":"栈数据结构后进先出（LIFO） 堆数据结构堆是一种树状结构，存取类似于图书馆 队列队列是一种先进先出（FIFO）的数据结构 变量的存放 基本数据类型：保存在栈内存中，因为这些数据类型在内存中占有固定大小的空间，按值访问。 注： undefined null Boolean Number String Symbol 引用数据类型：保存在堆内存中，因为这种值大小不固定，但是内存地址（因为大小固定）保存在堆内存中；在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。 内存管理空间 分配你所需要的内存 使用分配到的内存 不需要时释放 归还 JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。 ！！！赋值语句的执行顺序是从右至左 var a = {n: 1}; var b = a; a.x = a = {n: 2}; a.x // 这时 a.x 的值是多少 b.x // 这时 b.x 的值是多少","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.2 执行上下文栈和变量对象","slug":"js学习笔记/1.2 执行上下文栈和变量对象","date":"2017-05-06T12:11:48.000Z","updated":"2019-05-06T14:59:10.977Z","comments":true,"path":"2017/05/06/js学习笔记/1.2 执行上下文栈和变量对象/","link":"","permalink":"http://yoursite.com/2017/05/06/js学习笔记/1.2 执行上下文栈和变量对象/","excerpt":"","text":"变量提升： foo; // undefined var foo = function () { console.log(&apos;foo1&apos;); } foo(); // foo1，foo赋值 var foo = function () { console.log(&apos;foo2&apos;); } foo(); // foo2，foo重新赋值 函数提升： foo(); // foo2 function foo() { console.log(&apos;foo1&apos;); } foo(); // foo2 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo2 变量提升和函数提升优先级： foo(); // foo2 var foo = function() { console.log(&apos;foo1&apos;); } foo(); // foo1，foo重新赋值 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo1 执行上下文栈 JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。 函数上下文 在函数上下文中，用活动对象(activation object, AO)来表示变量对象。活动对象和变量对象的区别在于 1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。 2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问 执行过程 进入执行上下文 1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。 2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。 3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。 function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 代码执行 AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression &quot;d&quot; } 总结 1、全局上下文的变量对象初始化是全局对象 2、函数上下文的变量对象初始化只包括 Arguments 对象 3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 4、在代码执行阶段，会再次修改变量对象的属性值","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.1 执行上下文栈","slug":"js学习笔记/1.1 执行上下文栈","date":"2017-04-29T12:31:48.000Z","updated":"2019-05-06T14:29:21.930Z","comments":true,"path":"2017/04/29/js学习笔记/1.1 执行上下文栈/","link":"","permalink":"http://yoursite.com/2017/04/29/js学习笔记/1.1 执行上下文栈/","excerpt":"","text":"执行上下文：当前javascript代码被解析和执行所在环境的抽象概念 执行上下文类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象 函数执行上下文：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文 Eval执行上下文: eval()函数中的代码,很少用而且不建议使用 执行栈:也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 var a = &apos;1&apos;; function first() { console.log(&apos;Inside first function&apos;); second(); console.log(&apos;Again inside first function&apos;); } function second() { console.log(&apos;Inside second function&apos;); } first(); console.log(&apos;Inside Global Execution Context&apos;); // Inside first function // Inside second function // Again inside first function // Inside Global Execution Context 执行上下文的创建:执行上下文的创建分为两个阶段： 1）创建阶段2）执行阶段 创建阶段 确定this 全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象 创建词法环境 （全局环境和函数环境） 环境记录：存储变量和函数声明的实际位置 对外部环境的访问：访问外部词法环境 创建变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 执行阶段所有变量的分配，最后执行代码。 注： 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"执行栈","slug":"执行栈","permalink":"http://yoursite.com/tags/执行栈/"},{"name":"执行上下文","slug":"执行上下文","permalink":"http://yoursite.com/tags/执行上下文/"}]}]}