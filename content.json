{"meta":{"title":"让优秀成为一种习惯","subtitle":null,"description":"无数青山隔沧海,与谁同往却同归","author":"Mr.Tian","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-04-29T15:08:45.000Z","updated":"2019-04-29T15:16:56.679Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-16T13:16:12.000Z","updated":"2019-04-16T13:21:33.365Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-16T12:31:48.000Z","updated":"2019-04-16T13:12:22.487Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"3.1 this的绑定方式","slug":"js学习笔记/3.3 call和apply","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-14T14:48:17.527Z","comments":true,"path":"2017/07/20/js学习笔记/3.3 call和apply/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/3.3 call和apply/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"js学习笔记/3.1 this的绑定方式","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-15T15:02:49.546Z","comments":true,"path":"2017/07/20/js学习笔记/3.1 this的绑定方式/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/3.1 this的绑定方式/","excerpt":"","text":"this的绑定： 默认绑定 隐式绑定 显式绑定 new绑定 箭头函数绑定 调用位置调用位置就是函数在代码中被调用的位置（而不是声明的位置） 绑定规则默认绑定 独立函数的调用：this -&gt; window 严格模式下，不能讲全局对象用于默认绑定，this会绑定到undefined.只有函数在非严格模式下，默认绑定才绑定到window上。 function foo() { // 运行在严格模式下，this会绑定到undefined &quot;use strict&quot;; console.log( this.a ); } var a = 2; // 调用 foo(); // TypeError: Cannot read property &apos;a&apos; of undefined // -------------------------------------- function foo() { // 运行 console.log( this.a ); } var a = 2; (function() { // 严格模式下调用函数则不影响默认绑定 &quot;use strict&quot;; foo(); // 2 })(); 隐式绑定function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj 对象。 然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它 无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj ，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置，举例来说： function foo() { console.log( this.a ); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42 隐式丢失一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名！ var a = &quot;oops, global&quot;; // a 是全局对象的属性 bar(); // &quot;oops, global&quot; 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时: function foo() { console.log( this.a ); } function doFoo(fn) { // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！ } var obj = { a: 2, foo: foo }; var a = &quot;oops, global&quot;; // a 是全局对象的属性 doFoo( obj.foo ); // &quot;oops, global&quot; 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样 如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别： function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var a = &quot;oops, global&quot;; // a 是全局对象的属性 setTimeout( obj.foo, 100 ); // &quot;oops, global&quot; JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似： function setTimeout(fn,delay) { // 等待 delay 毫秒 fn(); // &lt;-- 调用位置！ } 显式绑定（call/apply）在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？ JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关——之后我们会详细介绍原型），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。 call()和apply()的第一个参数是一个对象，他们会把这个对象绑定到this，在函数调用时指定这个this就是第一个参数对象，因为可以直接指定this的绑定对象，所以叫做显式绑定。 function foo() { console.log( this.a ); } var obj = { a:2 }; foo.call( obj ); // 2 通过foo.call(obj), 我们在调用foo时会把他的this指定到obj对象。 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..) 、 new Boolean(..) 或者new Number(..) ）。这通常被称为“装箱” 硬绑定解决我们之前提出的丢失绑定问题。 function foo() { console.log( this.a ); } var obj = { a:2 }; var bar = function() { foo.call( obj ); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this bar.call( window ); // 2 我们来看看这个变种到底是怎样工作的。我们创建了函数 bar() ，并在它的内部手动调用了 foo.call(obj) ，因此强制把 foo 的 this 绑定到了 obj 。无论之后如何调用函数 bar ，它总会手动在 obj 上调用 foo 。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。 硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值： function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a:2 }; var bar = function() { return foo.apply( obj, arguments ); }; var b = bar( 3 ); // 2 3 console.log( b ); // 5 另一种使用方法是创建一个 i 可以重复使用的辅助函数 function foo(something) { console.log( this.a, something ); return this.a + something; } // 简单的辅助绑定函数 function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); }; } var obj = { a:2 }; var bar = bind( foo, obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。 API调用的上下文第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this 。 function foo(el) { console.log( el, this.id ); } var obj = { id: &quot;awesome&quot; }; // 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome 这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些代码。 new绑定这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 JavaScript 中函数和对象的误解。 在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的： something = new MyClass(..); JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。 首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。 举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它： 当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。 所以，包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。5我们现在关心的是第 1 步、第 3 步、第 4 步，所以暂时跳过第 2 步，第 5 章会详细介绍它。 思考下面的代码： function foo(a) { this.a = a; } var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。 new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 参考：你不知道的javascript","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"js学习笔记/4.1 解析赋值、浅拷贝、深拷贝的区别 - 副本","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-14T14:48:17.527Z","comments":true,"path":"2017/07/20/js学习笔记/4.1 解析赋值、浅拷贝、深拷贝的区别 - 副本/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/4.1 解析赋值、浅拷贝、深拷贝的区别 - 副本/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"js学习笔记/4.2 Object.assign","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-14T14:48:17.527Z","comments":true,"path":"2017/07/20/js学习笔记/4.2 Object.assign/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/4.2 Object.assign/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"js学习笔记/3.2 理解箭头函数中this","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-14T14:48:17.527Z","comments":true,"path":"2017/07/20/js学习笔记/3.2 理解箭头函数中this/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/3.2 理解箭头函数中this/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"js学习笔记/3.5 new","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-14T14:48:17.527Z","comments":true,"path":"2017/07/20/js学习笔记/3.5 new/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/3.5 new/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"js学习笔记/3.4 bind","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-14T14:48:17.527Z","comments":true,"path":"2017/07/20/js学习笔记/3.4 bind/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/3.4 bind/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"3.1 this的绑定方式","slug":"js学习笔记/4.3 手动实现一个深拷贝","date":"2017-07-20T01:15:50.000Z","updated":"2019-05-14T14:48:17.527Z","comments":true,"path":"2017/07/20/js学习笔记/4.3 手动实现一个深拷贝/","link":"","permalink":"http://yoursite.com/2017/07/20/js学习笔记/4.3 手动实现一个深拷贝/","excerpt":"","text":"","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"2.2 从作用域链的角度看闭包","slug":"js学习笔记/2.2 从作用域的角度看闭包","date":"2017-06-17T11:25:50.000Z","updated":"2019-05-14T14:35:30.893Z","comments":true,"path":"2017/06/17/js学习笔记/2.2 从作用域的角度看闭包/","link":"","permalink":"http://yoursite.com/2017/06/17/js学习笔记/2.2 从作用域的角度看闭包/","excerpt":"","text":"首先我们来看一个函数： var scope = &quot;global scope&quot;; function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f; } var foo = checkscope(); // foo指向函数f foo(); // 调用函数f() 执行过程 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 函数f执行的时候，checkscope函数执行上下文已经被销毁，那么f函数怎么访问到scope变量呢？ 函数f 执行上下文维护了一个作用域链，会指向指向checkscope作用域 所以指向关系是当前作用域 –&gt; checkscope作用域–&gt; 全局作用域，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，这就是闭包实现的关键。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"2.1 理解闭包","slug":"js学习笔记/2.1 闭包的作用和优缺点","date":"2017-06-13T11:14:20.000Z","updated":"2019-05-14T14:07:16.123Z","comments":true,"path":"2017/06/13/js学习笔记/2.1 闭包的作用和优缺点/","link":"","permalink":"http://yoursite.com/2017/06/13/js学习笔记/2.1 闭包的作用和优缺点/","excerpt":"","text":"什么是闭包？闭包的优缺点？ 闭包（closure）是javascript的一大难点，也是它的特色。很多高级应用都要依靠闭包来实现。 变量作用域要理解闭包，首先要理解javascript的特殊的变量作用域。 变量的作用域无非就两种：全局变量和局部变量。 javascript语言的特别之处就在于： 函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ 如何从外部读取函数内部的局部变量？出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。 那就是在函数内部，再定义一个函数。 function f1(){ var n=999; function f2(){ alert(n); // 999 } } 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 这就是Javascript语言特有的”链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包的用途闭包可以用在许多地方。它的最大用处有两个， 一个是前面提到的可以读取函数内部的变量 另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.5 内存泄漏如何避免","slug":"js学习笔记/1.5 内存泄漏如何避免","date":"2017-05-29T13:34:20.000Z","updated":"2019-05-08T15:42:22.852Z","comments":true,"path":"2017/05/29/js学习笔记/1.5 内存泄漏如何避免/","link":"","permalink":"http://yoursite.com/2017/05/29/js学习笔记/1.5 内存泄漏如何避免/","excerpt":"","text":"垃圾回收算法常用垃圾回收算法叫做标记清除 （Mark-and-sweep） ，算法由以下几步组成： 垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾） 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。 本质：可达内存被标记，其余的被当作垃圾回收 四种常见的JS内存泄漏意外的全局变量1 function foo(arg) { bar = &quot;this is a hidden global variable&quot;; } 函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。 2 function foo() { this.variable = &quot;potential accidental global&quot;; } // Foo 调用自己，this 指向了全局对象（window） // 而不是 undefined foo(); 解决方法：使用’use strict’ 被遗忘的计时器或回调函数var someResource = getData(); setInterval(function() { var node = document.getElementById(&apos;Node&apos;); if(node) { // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); } }, 1000); 在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。 var element = document.getElementById(&apos;button&apos;); function onClick(event) { element.innerHTML = &apos;text&apos;; } element.addEventListener(&apos;click&apos;, onClick); 对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。 现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。 脱离 DOM 的引用如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。 var elements = { button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;) }; function doStuff() { image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑 } function removeButton() { // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 } 闭包var theThing = null; var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) console.log(&quot;hi&quot;); }; theThing = { longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () { console.log(someMessage); } }; }; setInterval(replaceThing, 1000); 每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。 解决方法：在 replaceThing 的最后添加 originalThing = null 。 问题 从内存来看 null 和 undefined 本质的区别是什么？ 给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值 ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？ const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: “foo” is read-only const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.4 内存机制","slug":"js学习笔记/1.4 内存机制","date":"2017-05-22T11:11:20.000Z","updated":"2019-05-08T14:44:25.246Z","comments":true,"path":"2017/05/22/js学习笔记/1.4 内存机制/","link":"","permalink":"http://yoursite.com/2017/05/22/js学习笔记/1.4 内存机制/","excerpt":"","text":"JS内存空间栈内存（stack）：存放变量 堆内存（heap）：存放复杂对象 池（一般也归类栈中）：存放常量 function A() { let a = 1 function B() { console.log(a) } return B } 闭包中变量保存在堆内存中，这也是为什么闭包可以访问到函数内的变量内存回收js有自动垃圾回收机制，垃圾收集器会每个一段时间就执行一次释放操作，找出那些不在继续使用的值，然后释放其占用的内存。 局部变量和全局变量的销毁 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量 以Google的V8引擎为例，V8引擎中的所有的JS独享都是通过对来金鹰内粗分配的 初始分配：声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止 V8引擎对堆内存中的JS对象进行分代管理 新生代：存活周期较短的JS对象，如临时变量、字符串等。老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。 垃圾回收算法对垃圾回收算法来说，核心思想就是如何判断内存已经不使用了，常用垃圾回收算法： 引用计数（现在浏览器不再使用） 标记清除 引用计数引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。 // 创建一个对象person，他有两个指向属性age和name的引用 var person = { age: 12, name: &apos;aaaa&apos; }; person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收 var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收 p = null; //原person对象已经没有引用，很快会被回收 引用计数有一个致命问题就是循环引用 cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。 function cycle() { var o1 = {}; var o2 = {}; o1.a = o2; o2.a = o1; return &quot;cycle reference!&quot; } cycle(); 如果两个对象相互引用，尽管他们已经不在使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄漏。 标记清除标记清除将“将不再使用的队形”定义为无法到达的对象。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。 对于主流浏览器来说，只需要切断需要回收的对象与根部的联系，就可以被垃圾回收机制回收 email.message = document.createElement(“div”); displayList.appendChild(email.message); // 稍后从displayList中清除DOM元素 displayList.removeAllChildren(); 上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。 内存泄漏对于持续与逆行的服务进程，必须及时释放不在用到的内存废旧则内存占用的越来越高，轻则影响到系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就叫做内存泄漏。 内存泄漏识别方法 谷歌浏览器：Memory -&gt; Select profiling -&gt; timeline -&gt; start -&gt; stop node process.memoryUsage WeakMapES6新的数据结构 WeakSet 和 WeakMap，表示这是弱引用，他们对于值的引用都是不计入垃圾回收机制的 const wm = new WeakMap(); const element = document.getElementById(&apos;example&apos;); wm.set(element, &apos;some information&apos;); wm.get(element) // &quot;some information&quot; 先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.3 栈堆队列理解","slug":"js学习笔记/1.3 栈堆队列理解","date":"2017-05-15T01:11:48.000Z","updated":"2019-05-06T15:27:41.041Z","comments":true,"path":"2017/05/15/js学习笔记/1.3 栈堆队列理解/","link":"","permalink":"http://yoursite.com/2017/05/15/js学习笔记/1.3 栈堆队列理解/","excerpt":"","text":"栈数据结构后进先出（LIFO） 堆数据结构堆是一种树状结构，存取类似于图书馆 队列队列是一种先进先出（FIFO）的数据结构 变量的存放 基本数据类型：保存在栈内存中，因为这些数据类型在内存中占有固定大小的空间，按值访问。 注： undefined null Boolean Number String Symbol 引用数据类型：保存在堆内存中，因为这种值大小不固定，但是内存地址（因为大小固定）保存在堆内存中；在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。 内存管理空间 分配你所需要的内存 使用分配到的内存 不需要时释放 归还 JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。 ！！！赋值语句的执行顺序是从右至左 var a = {n: 1}; var b = a; a.x = a = {n: 2}; a.x // 这时 a.x 的值是多少 b.x // 这时 b.x 的值是多少","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.2 执行上下文栈和变量对象","slug":"js学习笔记/1.2 执行上下文栈和变量对象","date":"2017-05-06T12:11:48.000Z","updated":"2019-05-06T14:59:10.977Z","comments":true,"path":"2017/05/06/js学习笔记/1.2 执行上下文栈和变量对象/","link":"","permalink":"http://yoursite.com/2017/05/06/js学习笔记/1.2 执行上下文栈和变量对象/","excerpt":"","text":"变量提升： foo; // undefined var foo = function () { console.log(&apos;foo1&apos;); } foo(); // foo1，foo赋值 var foo = function () { console.log(&apos;foo2&apos;); } foo(); // foo2，foo重新赋值 函数提升： foo(); // foo2 function foo() { console.log(&apos;foo1&apos;); } foo(); // foo2 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo2 变量提升和函数提升优先级： foo(); // foo2 var foo = function() { console.log(&apos;foo1&apos;); } foo(); // foo1，foo重新赋值 function foo() { console.log(&apos;foo2&apos;); } foo(); // foo1 执行上下文栈 JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。 函数上下文 在函数上下文中，用活动对象(activation object, AO)来表示变量对象。活动对象和变量对象的区别在于 1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。 2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问 执行过程 进入执行上下文 1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。 2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。 3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。 function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 代码执行 AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression &quot;d&quot; } 总结 1、全局上下文的变量对象初始化是全局对象 2、函数上下文的变量对象初始化只包括 Arguments 对象 3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 4、在代码执行阶段，会再次修改变量对象的属性值","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"1.1 执行上下文栈","slug":"js学习笔记/1.1 执行上下文栈","date":"2017-04-29T12:31:48.000Z","updated":"2019-05-06T14:29:21.930Z","comments":true,"path":"2017/04/29/js学习笔记/1.1 执行上下文栈/","link":"","permalink":"http://yoursite.com/2017/04/29/js学习笔记/1.1 执行上下文栈/","excerpt":"","text":"执行上下文：当前javascript代码被解析和执行所在环境的抽象概念 执行上下文类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象 函数执行上下文：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文 Eval执行上下文: eval()函数中的代码,很少用而且不建议使用 执行栈:也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 var a = &apos;1&apos;; function first() { console.log(&apos;Inside first function&apos;); second(); console.log(&apos;Again inside first function&apos;); } function second() { console.log(&apos;Inside second function&apos;); } first(); console.log(&apos;Inside Global Execution Context&apos;); // Inside first function // Inside second function // Again inside first function // Inside Global Execution Context 执行上下文的创建:执行上下文的创建分为两个阶段： 1）创建阶段2）执行阶段 创建阶段 确定this 全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象 创建词法环境 （全局环境和函数环境） 环境记录：存储变量和函数声明的实际位置 对外部环境的访问：访问外部词法环境 创建变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 执行阶段所有变量的分配，最后执行代码。 注： 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"执行栈","slug":"执行栈","permalink":"http://yoursite.com/tags/执行栈/"},{"name":"执行上下文","slug":"执行上下文","permalink":"http://yoursite.com/tags/执行上下文/"}]}]}