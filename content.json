{"meta":{"title":"让优秀成为一种习惯","subtitle":null,"description":"无数青山隔沧海,与谁同往却同归","author":"Mr.Tian","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-04-16T13:16:12.000Z","updated":"2019-04-16T13:21:33.365Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-16T12:31:48.000Z","updated":"2019-04-16T13:12:22.487Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-04-29T15:08:45.000Z","updated":"2019-04-29T15:16:56.679Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"1.1 执行上下文栈","slug":"js学习笔记/1.1执行上下文栈","date":"2017-04-29T12:31:48.000Z","updated":"2019-05-06T14:25:03.775Z","comments":true,"path":"2017/04/29/js学习笔记/1.1执行上下文栈/","link":"","permalink":"http://yoursite.com/2017/04/29/js学习笔记/1.1执行上下文栈/","excerpt":"","text":"1 执行上下文：当前javascript代码被解析和执行所在环境的抽象概念 2 执行上下文类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象 函数执行上下文：存在无数个,只有在函数被调用的时候才会被创建,每次调用函数就会创建一个新的执行上下文 Eval执行上下文: eval()函数中的代码,很少用而且不建议使用 3 执行栈:也叫调用栈，具有后进先出（LIFO）的结构，用于存储代码在执行期间创建的所有的执行上下文 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 var a = &apos;1&apos;; function first() { console.log(&apos;Inside first function&apos;); second(); console.log(&apos;Again inside first function&apos;); } function second() { console.log(&apos;Inside second function&apos;); } first(); console.log(&apos;Inside Global Execution Context&apos;); // Inside first function // Inside second function // Again inside first function // Inside Global Execution Context 4 执行上下文的创建:执行上下文的创建分为两个阶段： 1）创建阶段2）执行阶段 4.1 创建阶段 确定this 全局执行上下文中,this指向全局对象，浏览器中this-&gt;windows对象，nodejs中-&gt; 文件的module对象 创建词法环境 （全局环境和函数环境） 环境记录：存储变量和函数声明的实际位置 对外部环境的访问：访问外部词法环境 创建变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 4.2 执行阶段所有变量的分配，最后执行代码。 注： 在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。","categories":[{"name":"js学习笔记","slug":"js学习笔记","permalink":"http://yoursite.com/categories/js学习笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"执行栈","slug":"执行栈","permalink":"http://yoursite.com/tags/执行栈/"},{"name":"执行上下文","slug":"执行上下文","permalink":"http://yoursite.com/tags/执行上下文/"}]}]}